[{"title":"计算机网络实践记录","url":"/2024/09/28/计算机网络实践记录/","content":"\n---\n- 天津大学 2024 计算机网络 TCP 课程实践\n- Lab Member：海棠未雨，梨花先雪\n- 最终成绩 +∞ 分捏 😋\n\n## 文件结构说明\n```markdown\ntju_tcp ----------------- 项目根目录 \n├─ build ---------------- 存放所有编译的中间文件\n│  ├─ kernel.o\n│  ├─ log.o\n│  ├─ operation.o\n│  ├─ rtt.o\n│  ├─ time_thread.o\n│  ├─ tju_packet.o\n│  └─ tju_tcp.o\n├─ inc ------------------ 存放所有头文件\n│  ├─ global.h ---------- 定义一些全局都会用到的变量和结构\n│  ├─ kernel.h ---------- 模拟一部分linux内核行为 比如如何发送数据到下一层 根据五元组查找socket等\n│  ├─ tju_packet.h ------ 定义TCP所用到的数据包格式 提供各种数据包的操作(创建 获得字段等)\n│  ├─ tju_tcp.h --------- 需要实现的TCP的各种结构和功能的定义\n│  ├─ log.h\n│  ├─ operation.h\n│  ├─ rtt.h\n│  └─ time_thread.h\n├─ src ------------------ 存放所有源代码文件\n│  ├─ client.c ---------- 客户端主函数实现\n│  ├─ server.c ---------- 服务端主函数实现\n│  ├─ kernel.c ---------- 虚拟内核实现\n│  ├─ tju_packet.c ------ 可靠层包封装实现\n│  ├─ tju_tcp.c --------- 可靠层实现\n│  ├─ log.c ------------- 日志实现\n│  ├─ operation.c ------- 数据包及缓冲区操作\n│  ├─ rtt.c ------------- RTT计算实现\n│  └─ time_thread.c ----- 计时线程函数实现\n├─ Makefile ------------- 生成脚本\n├─ README.md ------------ 文件说明\n└─ bin\n   ├─ client\n   └─ server\n```\n\n## 具体实验记录\n\n### 连接管理\n\n### 可靠数据传输\n\n### 流量控制\n\n### 拥塞控制","tags":["计算机网络"]},{"title":"C语言手写Httpd网站服务器","url":"/2024/09/26/C语言手写Httpd网站服务器/","content":"\n---\n## 执行WEB服务前的准备工作\n### 创建项目\n```C\n#include <stdio.h>\n\n// 初始化网络并创建服务端的套接字\nint startup(unsigned short* port){\n    return 0;\n}\n\nint main(void){\n    //httpd默认的端口是80，这里指定了8000端口，也可以使用其它端口\n    unsigned short port = 8000;\n\n    // 初始化网络，并使用指定端口来创建服务端的套接字\n    int server_sock = startup(&port);\n    printf(\"httpd running on port %d\\n\", port);\n\n    return(0);\n}\n```\n### 网络通信初始化\n```C\n//网络通信需要包含的头文件、需要加载的库文件\n#include <winsock2.h>\n#pragma comment (lib, \"WS2_32.lib\")\n\n// 初始化网络并创建服务端的套接字\nint startup(unsigned short* port) {\n    WSADATA wsaData; // 网络通信相关的版本等信息\n    int ret = WSAStartup( // WSAStartup 网络通信初始化，\n        MAKEWORD(1, 1),   // 指定使用Windows Sockets规范的1.1版本\n        &wsaData);        // 存储初始化后的版本等信息结果\n    if (ret) {\n        return -1;\n    }\n\n    return 0;\n}\n```\n### 创建套接字\n```C\nvoid error_die(const char* sc) {\n    perror(sc); //打印错误原因\n    exit(1);\n}\n\n// 初始化网络并创建服务端的套接字\nint startup(unsigned short* port) {\n    int server_socket = socket(PF_INET, //套接字的类型（网络套接字、文件套接字，此处是前者）\n        SOCK_STREAM,  //数据包的类型（数据流、数据报，此处是前者）               \n        IPPROTO_TCP); //具体协议\n    if (server_socket == -1) { //打印错误提示，并结束程序\n        error_die(\"socket\");\n    }\n}\n```\n### 设置套接字属性--端口可复用\n```C\n// 初始化网络并创建服务端的套接字\nint startup(unsigned short* port) {\n    //设置端口可复用（端口复用）\n    int opt = 1;\n    ret = setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (const char*)&opt, sizeof(opt));\n    if (ret == -1) {\n        error_die(\"setsockopt\");\n    }\n}\n```\n### 绑定套接字和网络地址\n```C\nint startup(unsigned short* port) {\n    //配置服务器的网络地址\n    struct sockaddr_in server_addr;\n    memset(&server_addr, 0, sizeof(server_addr));\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(*port);\n    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n    \n    //绑定套接字\n    if (bind(server_socket, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        error_die(\"[bind]\");\n    }\n}\n```\n### 获取动态端口\n```C\nint startup(unsigned short* port) {\n    // 动态分配端口\n    if (*port == 0) {\n        int namelen = sizeof(server_addr);\n        if (getsockname(server_socket, (struct sockaddr*)&server_addr, &namelen) <0) {\n            error_die(\"getsockname\");\n        }\n        *port = ntohs(server_addr.sin_port);\n    }\n    return server_socket;\n}\n```\n### 创建监听队列\n```C\nint startup(unsigned short* port) {\n    //创建监听队列\n    if (listen(server_socket, 5) < 0) {\n        error_die(\"listen\");\n    }\n    return server_socket;\n}\n```","tags":["服务器"]},{"title":"C语言手写植物大战僵尸","url":"/2024/09/26/C语言手写植物大战僵尸/","content":"\n---\n## C语言手写植物大战僵尸\n### 创建主场景\n```C\n#include<stdio.h>\n#include<graphics.h>\n\n#define WIN_WIDTH 900\n#define WIN_HEIGHT 600\n\nIMAGE imgBg;\n\n//游戏初始化\nvoid gameInit() {\n\tloadimage(&imgBg, \"res/bg.jpg\");\n\n\tinitgraph(WIN_WIDTH, WIN_HEIGHT);\n}\n\n//更新窗口\nvoid updateWindow() {\n\tputimage(0, 0, &imgBg);\n}\n\nint main(void) {\n\t//游戏初始化\n\tgameInit();\n\n\t//更新窗口\n\tupdateWindow();\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n### 实现植物卡牌\n```C\n#include \"tools.h\"\n\n//#define ZHI_WU_CUNT 3\n\nenum { WAN_DOU, XIANG_RI_KUI, ZHI_WU_COUNT };\n\nIMAGE imgBar;\nIMAGE imgCards[ZHI_WU_COUNT];\n\nvoid gameInit() {\n\tloadimage(&imgBar, \"res/bar.png\");\n\n\t//初始化植物卡牌\n\tchar name[64];\n\tfor (int i = 0; i < ZHI_WU_COUNT; i++) {\n\t\t//生成植物卡牌的文件名\n\t\tsprintf_s(name, sizeof(name), \"res/Cards/card_%d.png\", i + 1);\n\t\tloadimage(&imgCards[i], name);\n\t}\n}\n\nvoid updateWindow() {\n\t//putimage(250, 0, &imgBar); //有黑边\n\tputimagePNG(250, 0, &imgBar);\n\n\tfor (int i = 0; i < ZHI_WU_COUNT; i++) {\n\t\tint x = 338 + i * 65;\n\t\tint y = 6;\n\t\tputimage(x, y, &imgCards[i]);\n\t}\n}\n```\n### 实现植物的选择和拖动\n```C\nIMAGE* imgZhiWu[ZHI_WU_COUNT][20];\n\nint curX, curY; //当前选中的植物，在移动过程中的位置\nint curZhiWu; //0:没有选中，1:选择了第一种植物 etc.\n\nbool fileExist(const char* name) {\n\tFILE* fp = fopen(name, \"r\");\n\tif (fp == NULL) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfclose(fp);\n\t\treturn true;\n\t}\n}\n\nvoid gameInit() {\n\tmemset(imgZhiWu, 0, sizeof(imgZhiWu));\n\n\t//初始化植物卡牌\n\tchar name[64];\n\tfor (int i = 0; i < ZHI_WU_COUNT; i++) {\n\t\tfor (int j = 0; j < 20; j++) {\n\t\t\tsprintf_s(name, sizeof(name), \"res/zhiwu/%d/%d.png\", i, j + 1);\n\t\t\t//先判断这个文件是否存在\n\t\t\tif (fileExist(name)) {\n\t\t\t\timgZhiWu[i][j] = new IMAGE;\n\t\t\t\tloadimage(imgZhiWu[i][j], name);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tcurZhiWu = 0;\n\t//创建游戏的图形窗口\n\tinitgraph(WIN_WIDTH, WIN_HEIGHT, 1); //加一个参数1，保留后台界面，方便调试\n}\n\nvoid updateWindow() {\n\tBeginBatchDraw(); //开始缓冲（先打印到内存中）\n\n\t//渲染 拖动过程中的植物\n\tif (curZhiWu > 0) {\n\t\tIMAGE* img = imgZhiWu[curZhiWu - 1][0];\n\t\tputimagePNG(curX - img->getwidth() / 2, curY - img->getheight() / 2, img);\n\t}\n\n\tEndBatchDraw(); //结束双缓冲（再一次性打印到窗口）\n}\nvoid userClick() {\n\tExMessage msg;\n\tstatic int status = 0;//状态变量（先点击再拖动）\n\tif (peekmessage(&msg)) {\n\t\tif (msg.message == WM_LBUTTONDOWN) { //左击按下\n\t\t\tif (msg.x > 338 && msg.x < 338 + 65 * ZHI_WU_COUNT && msg.y < 96) {\n\t\t\t\tint index = (msg.x - 338) / 65; //选择卡牌序号\n\t\t\t\tprintf(\"%d\\n\", index);\n\t\t\t\tstatus = 1; //可以拖动\n\t\t\t\tcurZhiWu = index + 1;\n\t\t\t}\n\t\t}\n\t\telse if (msg.message == WM_MOUSEMOVE && status == 1) { //鼠标移动\n\t\t\tcurX = msg.x;\n\t\t\tcurY = msg.y;\n\n\t\t}\n\t\telse if (msg.message == WM_LBUTTONUP) { //左键抬起\n\n\t\t}\n\t}\n\n}\nint main(void) {\n\tgameInit();\n\n\twhile (1) {\n\t\tuserClick();\n\n\t\tupdateWindow();\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n### 实现植物的种植\n```C\nstruct zhiwu {\n\tint type;\t\t//0:没有选中，1:第一种植物\tetc.\t\t\t\t\n\tint frameIndex; //序列帧的序号\n};\n\nstruct zhiwu map[3][9];\n\nvoid gameInit() {\n\tmemset(map, 0, sizeof(map));\n}\n\nvoid updateWindow() {\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 9; j++) {\n\t\t\tif (map[i][j].type > 0) {\n\t\t\t\tint x = 256 + j * 81;\n\t\t\t\tint y = 179 + i * 102 + 14;\n\t\t\t\tint zhiWuType = map[i][j].type - 1;\n\t\t\t\tint index = map[i][j].frameIndex;\n\t\t\t\tputimagePNG(x, y, imgZhiWu[zhiWuType][index]);\n\t\t\t}\n\t\t}\n\t}\n}\nvoid userClick() {\n\tif (peekmessage(&msg)) {\n\t\telse if (msg.message == WM_LBUTTONUP) { //左键抬起\n\t\t\tif (msg.x > 256 && msg.y > 179 && msg.y < 489) {\n\t\t\t\tint row = (msg.y - 179) / 102;\n\t\t\t\tint col = (msg.x - 256) / 81;\n\t\t\t\t//printf(\"%d, %d\\n\", row, col);\n\t\t\t\tif (map[row][col].type == 0) {\n\t\t\t\t\tmap[row][col].type = curZhiWu;\n\t\t\t\t\tmap[row][col].frameIndex = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurZhiWu = 0;\n\t\t\tstatus = 0;\n\t\t}\n\t}\n}\n```\n### 实现植物的摇摆\n```C\n//更新游戏相关数据\nvoid updateGame() {\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 9; j++) {\n\t\t\tif (map[i][j].type > 0) {\n\t\t\t\tmap[i][j].frameIndex++;\n\t\t\t\tint zhiWuType = map[i][j].type - 1;\n\t\t\t\tint index = map[i][j].frameIndex;\n\t\t\t\tif (imgZhiWu[zhiWuType][index] == NULL) {\n\t\t\t\t\tmap[i][j].frameIndex = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void) {\n\tgameInit();\n\twhile (1) {\n\t\tuserClick();\n\n\t\tupdateWindow();\n\t\tupdateGame(); //更新游戏相关数据\n\n\t\tSleep(10);//帧等待\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n### 优化游戏循环和游戏渲染循序\n```C\nvoid updateWindow() {\n\tBeginBatchDraw(); //开始缓冲\n\n\t//渲染 拖动过程中的植物（放到了最后）\n\tif (curZhiWu > 0) {\n\t\tIMAGE* img = imgZhiWu[curZhiWu - 1][0];\n\t\tputimagePNG(curX - img->getwidth() / 2, curY - img->getheight() / 2, img);\n\t}\n\n\tEndBatchDraw(); //结束双缓冲\n}\n\nint main(void) {\n\tgameInit();\n\tint timer = 0;\n\tbool flag = true;\n\twhile (1) {\n\t\tuserClick();\n\t\ttimer += getDelay();\n\t\tif (timer > 20) {\n\t\t\tflag = true;\n\t\t\ttimer = 0;\n\t\t}\n\n\t\tif (flag) {\n\t\t\tflag = false;\n\t\t\tupdateWindow();\n\t\t\tupdateGame();\n\t\t}\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n### 制作启动菜单\n```C\nvoid startUI() { //启动菜单\n\tIMAGE imgBg,imgMenu1,imgMenu2;\n\tloadimage(&imgBg, \"res/menu.png\");\n\tloadimage(&imgMenu1, \"res/menu1.png\");\n\tloadimage(&imgMenu2, \"res/menu2.png\");\n\n\tint flag = 0;\n\twhile (1) {\n\t\tBeginBatchDraw();\n\t\tputimage(0, 0, &imgBg);\n\t\tputimagePNG(474, 75, flag ? &imgMenu2: &imgMenu1);\n\n\t\tExMessage msg;\n\t\tif (peekmessage(&msg)) {\n\t\t\tif (msg.message == WM_LBUTTONDOWN&&\n\t\t\t\t\tmsg.x>474&&msg.x<474+300&&\n\t\t\t\t\tmsg.y>75&&msg.y<75+140){\n\t\t\t\tflag = 1;\n\t\t\t\t//EndBatchDraw();\n\t\t\t}\n\t\t\telse if (msg.message == WM_LBUTTONUP&&flag) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tEndBatchDraw();\n\t}\n}\n\nint main(void) {\n\tgameInit();\n\n\tstartUI();\n\n\tint timer = 0;\n\tbool flag = true;\n\twhile (1) {\n\t\tuserClick();\n\t\ttimer += getDelay();\n\t\tif (timer > 20) {\n\t\t\tflag = true;\n\t\t\ttimer = 0;\n\t\t}\n\n\t\tif (flag) {\n\t\t\tflag = false;\n\t\t\tupdateWindow();\n\t\t\tupdateGame();\n\t\t}\n\n\t\tSleep(10);\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n### 创建随机阳光\n```C\n#include<time.h>\n\nstruct sunshineBall {\n\tint x, y; //阳光球在飘落过程中的坐标位置（x不变）\n\tint frameIndex; //当前显示的图片帧的序号\n\tint destY; //飘落的目标位置的y坐标\n\tbool used; //是否在使用\n};\n\n//阳光池\nstruct sunshineBall balls[10];\nIMAGE imgSunshineBall[29];\n\n\nvoid gameInit() {\n\tmemset(balls, 0, sizeof(balls));\n\tfor (int i = 0; i < 29; i++) {\n\t\tsprintf_s(name, sizeof(name), \"res/sunshine/%d.png\", i + 1);\n\t\tloadimage(&imgSunshineBall[i], name);\n\t}\n\n\t//配置随机种子\n\tsrand(time(NULL));\n}\n\nvoid creatSunshine() {\n\tstatic int count = 0;\n\tstatic int fre = 400;\n\tcount++;\n\tif (count >= fre) { //每fre帧创建一个阳光，fre随机改变\n\t\tfre = 200 + rand() % 200;\n\t\tcount = 0;\n\n\t\t//从阳光池中取一个可以使用的\n\t\tint ballMax = sizeof(balls) / sizeof(balls[0]);\n\n\t\tint i;\n\t\tfor (i = 0; i < ballMax && balls[i].used; i++);\n\t\tif (i >= ballMax) return;\n\n\t\tballs[i].used = true;\n\t\tballs[i].frameIndex = 0;\n\t\tballs[i].x = 260 + rand() % (900 - 260);\n\t\tballs[i].y = 60;\n\t\tballs[i].destY = 200 + (rand() % 4) * 90;\n\t}\n}\n\nvoid updateGame() {\n\tcreatSunshine();\n}\n```\n### 显示随机阳光\n```C\nstruct sunshineBall {\n\tint x, y; //阳光球在飘落过程中的坐标位置（x不变）\n\tint frameIndex; //当前显示的图片帧的序号\n\tint destY; //飘落的目标位置的y坐标\n\tbool used; //是否在使用\n\tint timer; //计时器\n};\n\nvoid updateWindow() {\n\tint ballMax = sizeof(balls) / sizeof(balls[0]);\n\tfor (int i = 0; i < ballMax; i++) {\n\t\tif (balls[i].used) {\n\t\t\tIMAGE* img = &imgSunshineBall[balls[i].frameIndex];\n\t\t\tputimagePNG(balls[i].x, balls[i].y, img);\n\t\t}\n\t}\n}\n\t\nvoid creatSunshine() {\n\tif (count >= fre) {\n\t\tballs[i].timer = 0;\n\t}\n}\n\nvoid updateSunshine() {\n\tint ballMax = sizeof(balls) / sizeof(balls[0]);\n\tfor (int i = 0; i < ballMax; i++) {\n\t\tif (balls[i].used) {\n\t\t\tballs[i].frameIndex = (balls[i].frameIndex + 1) % 29;\n\t\t\tif (balls[i].timer == 0) { //未到达地面\n\t\t\t\tballs[i].y += 2;\n\t\t\t}\n\t\t\tif (balls[i].y >= balls[i].destY) {\n\t\t\t\t//balls[i].used = false;\n\t\t\t\tballs[i].timer++;\n\t\t\t\tif (balls[i].timer > 100) { //掉到地面100帧之后\n\t\t\t\t\tballs[i].used = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid updateGame() {\n\tcreatSunshine(); //创建阳光\n\tupdateSunshine(); //更新阳光的状态\n}\n```\n### 收集阳光、显示阳光值\n```C\n#include<mmsystem.h>\n#pragma comment(lib,\"winmm.lib\")\n\nint sunshine; //总阳光值\n\nvoid gameInit() {\n\tsunshine = 150;\n\n\t//设置字体\n\tLOGFONT f;\n\tgettextstyle(&f);                     // 获取当前字体设置\n\tf.lfHeight = 30;                      // 设置字体高度为 48\n\tf.lfWidth = 15;\n\tstrcpy(f.lfFaceName, \"Segoe UI Black\"); \n\tf.lfQuality = ANTIALIASED_QUALITY;    // 设置输出效果为抗锯齿  \n\tsettextstyle(&f);                     // 设置字体样式\n\tsetbkmode(TRANSPARENT);\t\t\t\t  //背景模式透明\n\tsetcolor(BLACK);\t\t\t\t\t  //字体颜色\n}\n\nvoid updateWindow() {\n\tchar scoreText[8];\n\tsprintf_s(scoreText, sizeof(scoreText), \"%d\", sunshine);\n\touttextxy(276, 67, scoreText); //在指定位置输出文本--分数\n}\n\nvoid collectSunshine(ExMessage* msg) {\n\tint count = sizeof(balls) / sizeof(balls[0]);\n\tint w = imgSunshineBall[0].getwidth(); //阳光球宽度\n\tint h = imgSunshineBall[0].getheight();//阳光球高度\n\tfor (int i = 0; i < count; i++) {\n\t\tif (balls[i].used) {\n\t\t\tint x = balls[i].x;\n\t\t\tint y = balls[i].y;\n\t\t\tif (msg->x > x && msg->x < x + w && msg->y > y && msg->y < y + h) {\n\t\t\t\tballs[i].used = false;\n\t\t\t\tsunshine += 25;\n\t\t\t\tmciSendString(\"play res/sunshine.mp3\", 0, 0, 0); //添加音效\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid userClick() {\n\tExMessage msg;\n\tstatic int status = 0;\n\tif (peekmessage(&msg)) {\n\t\tif (msg.message == WM_LBUTTONDOWN) { //左击按下\n\t\t\tif (msg.x > 338 && msg.x < 338 + 65 * ZHI_WU_COUNT && msg.y < 96) {\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcollectSunshine(&msg);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}\n```","tags":["C PvZ"]},{"title":"Java 综合实战（一）","url":"/2024/09/24/Java 综合实战/","content":"\n---\n## Java 综合实战（一）\n### 健康计算器\n**需求：开发一个简单的健康计算器应用程序，它可以接受用户的输入（如年龄、性别、体重、身高），并计算出用户的 BMI（身体质量指数）和 BMR（基础代谢率）。**\n```Java\npackage test;\n\nimport java.util.Scanner;\n\npublic class test {\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n\n        System.out.println(\"请您输入您的身高：\");\n        double height=sc.nextDouble();\n\n        System.out.println(\"请您输入您的体重：\");\n        double weight=sc.nextDouble();\n\n        System.out.println(\"请您输入您的性别（男/女）：\");\n        String sex=sc.next();\n\n        System.out.println(\"请您输入您的年龄：\");\n        int age=sc.nextInt();\n\n        double bmi=calcBMI(height,weight);\n        System.out.println(\"您的BMI值为：\"+bmi);\n\n        double bmr=calcBMR(height,weight,age,sex);\n        System.out.println(\"您的BMR值为：\"+bmr);\n    }\n\n    public static double calcBMI(double height,double weight){\n        return weight/(height*height);\n    }\n\n    public static double calcBMR(double height,double weight,int age,String sex){\n        double bmr=0;\n        if(sex.equals(\"男\")){\n            bmr=88.362+13.397*weight+4.799*height-5.677*age;\n        }\n        else{\n            bmr=447.593+9.247*weight+3.098*height-4.330*age;\n        }\n        return bmr;\n    }\n}\n```\n### 简单计算器\n**需求：设计一个可以执行基本数学运算（加、减、乘、除）的计算器程序。** \n**功能描述：用户输入两个数字、一个运算符（+、-、*、/）。根据所选运算符执行相应的数学运算，显示运算结果。**\n```Java\npackage test1;\n\nimport java.util.Scanner;\n\npublic class test1 {\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n\n        System.out.println(\"请输入第一个数字：\");\n        double num1=sc.nextDouble();\n\n        System.out.println(\"请输入第二个数字：\");\n        double num2=sc.nextDouble();\n\n        System.out.println(\"请输入运算符（+、-、*、/）：\");\n        String operator=sc.next();\n\n        double result=calculate(num1,num2,operator);\n        System.out.println(\"计算结果为：\"+result);\n    }\n\n    public static double calculate(double num1,double num2,String operator){\n        double result=0;\n        switch (operator){\n            case \"+\":\n                result=num1+num2;\n                break;\n            case \"-\":\n                result=num1-num2;\n                break;\n            case \"*\":\n                result=num1*num2;\n                break;\n            case \"/\":\n                result=num1/num2;\n                break;\n            default:\n                System.out.println(\"输入的运算符有误！\");\n        }\n        return result;\n    }\n}\n```\n### 猜数字小游戏\n**需求：随机生成一个1-100之间的数据，提示用户猜测，猜大提示过大，猜小提示过小，直到猜中结束游戏。**\n```Java\npackage test1;\n\nimport java.util.Random;\nimport java.util.Scanner;\n\npublic class test2 {\n    public static void main(String[] args) {\n        guessNumber();\n    }\n\n    public static void guessNumber(){\n        /*方法一*/\n        //Math.random()返回[0,1)之间的随机小数\n        //(int)(Math.random()*100)==>[0,100)的整数==>[0,99]+1==>[1,100]\n        //int number=(int)(Math.random()*100)+1;\n\n        /*方法二*/\n        Random r=new Random();\n        int number=r.nextInt(100)+1;\n\n        Scanner sc=new Scanner(System.in);\n\n        while(true){\n            System.out.println(\"请输入一个1~100之间的数字：\");\n            int guess=sc.nextInt();\n            if(guess<number){\n                System.out.println(\"猜小了，再试试吧！\");\n            }\n            else if(guess>number){\n                System.out.println(\"猜大了，再试试吧！\");\n            }\n            else{\n                System.out.println(\"恭喜你猜对了！\");\n                break;\n            }\n        }\n    }\n}\n```\n### 开发一个验证码\n**需求：开发一个程序，可以生成指定位数的验证码，每位可以是数字，大小写字母。**\n```Java\npackage test1;\n\npublic class test3 {\n    public static void main(String[] args) {\n        System.out.println(getCode(6));\n    }\n\n    public static String getCode(int n){\n        String code=\"\";\n\n        for(int i=0;i<n;i++){\n            int type=(int)(Math.random()*3); //数字0/大写1/小写2\n            \n            switch(type){\n                case 0:\n                    int num=(int)(Math.random()*10);\n                    code+=num;\n                    break;\n                case 1:\n                    int num1=(int)(Math.random()*26)+65;\n                    code+=(char)num1;\n                    break;\n                case 2:\n                    int num2=(int)(Math.random()*26)+97;\n                    code+=(char)num2;\n                    break;\n            }\n        }\n        return code;\n    }\n}\n```\n### 找素数\n**需求：输出101-200之间的所有素数以及总个数。**\n```Java\npackage test1;\n\npublic class test4 {\n    public static void main(String[] args) {\n        //目标：找出101-200之间的全部素数\n        int count=0;\n        for(int i=101;i<=200;i++){\n            if(isPrime(i)){\n                System.out.println(i);\n                count++;\n            }\n        }\n        System.out.println(\"素数的个数为：\"+count);\n    }\n\n    public static boolean isPrime(int num){\n        for(int i=2;i*i<=num;i++){\n            if(num%i==0){\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n### 斗地主游戏\n**需求：开发一个简易版的斗地主游戏，要求只完成做牌（存储54张牌）、洗牌。**\n```Java\npackage test2;\n\npublic class test1 {\n    public static void main(String[] args) {\n       start();\n    }\n    public static void start(){\n        String[] poker=new String[54];\n        String[] colors={\"♠\",\"♥\",\"♣\",\"♦\"};\n        String[] nums={\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"J\",\"Q\",\"K\",\"A\"};\n\n        int index=0;\n        for(int i=0;i<colors.length;i++){\n            for(int j=0;j<nums.length;j++){\n                poker[index++]=colors[i]+nums[j];\n            }\n        }\n        poker[index++]=\"Big Joker\";\n        poker[index++]=\"Small Joker\";\n\n        //打印牌\n        for(int i=0;i<poker.length;i++){\n            System.out.print(poker[i]+\"\\t\");\n        }\n        System.out.println();\n\n        //洗牌\n        for(int i=0;i<poker.length;i++){\n            int j=(int)(Math.random()*poker.length);\n            String temp=poker[i];\n            poker[i]=poker[j];\n            poker[j]=temp;\n        }\n\n        System.out.println(\"洗牌后：\");\n        for(int i=0;i<poker.length;i++){\n            System.out.print(poker[i]+\"\\t\");\n        }\n        System.out.println();\n    }\n}\n```\n### 石头迷阵游戏\n**需求：只需完成数据初始化**\n```Java\npackage test2;\n\npublic class test2 {\n    public static void main(String[] args) {\n        start(5);\n    }\n    public static void start(int n) {\n       int[][] arr=new int[n][n];\n\n       int count=1;\n       for(int i=0;i<n;i++){\n           for(int j=0;j<n;j++){\n               arr[i][j]=count++;\n           }\n       }\n\n       print(arr);\n\n       //打乱二维数组中的元素顺序\n        for(int i=0;i<arr.length;i++){\n            for(int j=0;j<arr[i].length;j++){\n                int x=(int)(Math.random()*arr.length);\n                int y=(int)(Math.random()*arr[i].length);\n                int temp=arr[i][j];\n                arr[i][j]=arr[x][y];\n                arr[x][y]=temp;\n            }\n        }\n        System.out.println(\"------------------\");\n        System.out.println(\"打乱后：\");\n        print(arr);\n    }\n    public static void print(int[][] arr){\n        for(int i=0;i<arr.length;i++){\n            for(int j=0;j<arr[i].length;j++){\n                System.out.print(arr[i][j]+\"\\t\");\n            }\n            System.out.println();\n        }\n    }\n}\n```","tags":["Java"]},{"title":"Markdown 语法","url":"/2024/09/09/Markdown语法/","content":"\n## Markdown 标题\n``` markdown\n# 一级标题\n\n## 二级标题\n\n### 三级标题\n\n#### 四级标题\n\n##### 五级标题\n\n###### 六级标题\n```\n&nbsp;**或者在文本下方添加任意数量的 = 或 - 分别用于表示一级标题或二级标题**\n``` markdown\n一级标题\n=========\n\n二级标题\n---------\n```\n\n## Markdown 字体\n``` markdown\n*斜体文字*\n\n_斜体文字_\n\n**粗体文字**\n\n__粗体文字__\n\n***粗斜体文字***\n\n___粗斜体文字___\n```\n\n## Markdown 引用\n``` markdown\n>这是引用的内容\n\n>>这是引用的内容\n\n>>>>>>>>>>这是引用的内容\n```\n\n## Markdown 分割线\n&nbsp;**三个或者三个以上的 - 或者 * 或者 _ 都可以**\n``` markdown\n---\n\n****\n\n____\n```\n  \n## Markdown 下划线\n``` markdown\n<u>带下划线文本</u>   \n```\n\n## Markdown 删除线\n``` markdown \n~~tencent.com~~\n```\n\n## Markdown 图片\n### 插入互联网上图片\n``` markdown\n![图片描述](图片链接 ''图片title'')\n```\n>图片描述就是显示在图片下面的文字，相当于对图片内容的解释。\n图片title是图片的标题，当鼠标移到图片上时显示的内容。\n注意：title可加可不加，图片描述可写可不写。\n\n### 插入本地图片\n``` markdown\n![图片描述](图片本地路径 ''图片title'')\n```\n>图片描述就是显示在图片下面的文字，相当于对图片内容的解释。\n图片title是图片的标题，当鼠标移到图片上时显示的内容。\n注意：title可加可不加，图片描述可写可不写。\n\n## Markdown 超链接\n``` markdown\n[超链接名](超链接地址 \"超链接title\")\n```\n&nbsp;**注：title可加可不加**\n\n## Markdown 列表\n### 无序列表\n&nbsp;**无序列表用 - + * 任何一种都可以**\n``` markdown\n* 第一项\n* 第二项\n* 第三项\n\n+ 第一项\n+ 第二项\n+ 第三项\n\n- 第一项\n- 第二项\n- 第三项\n```\n### 有序列表\n``` markdown\n1. 第一项\n2. 第二项\n3. 第三项\n```\n### 嵌套列表\n&nbsp;**上一级和下一级之间敲一个Tab键即可**\n``` markdown\n1. 第一项：\n    - 第一项嵌套的第一个元素\n    - 第一项嵌套的第二个元素\n2. 第二项：\n    - 第二项嵌套的第一个元素\n    - 第二项嵌套的第二个元素\n```\n\n## Markdown 表格\n``` markdown\n|表头|表头|表头|\n|---|:--:|---:|\n|内容|内容|内容|\n|内容|内容|内容|\n```\n\n>第二行分割表头和内容\n>-有一个就行，为了对齐，多加了几个\n>文字默认居左\n>-两边加：表示文字居中\n>-右边加：表示文字居右\n\n## Markdown 代码\n### 单行代码\n``` markdown\n`hello world`\n```\n\n### 代码块\n``` markdown\n(```)语言\n  代码内容\n(```)\n```\n\n## Markdown 流程图\n``` markdown\n(```)flow\nst=>start: 开始\nop=>operation: My Operation\ncond=>condition: Yes or No?\ne=>end\nst->op->cond\ncond(yes)->e\ncond(no)->op\n(```)\n```\n## Markdown 换行\n``` markdown\n连续两个以上空格+回车\n```\n&nbsp;**或者**\n``` markdown\n使用html语言换行标签<br>\n```\n\n## Markdown 缩进字符\n``` markdown\n&nbsp;  缩进1/4中文\n&ensp;  缩进半个中文，一个字符\n&emsp;  缩进一个中文，2个字符\n```","tags":["Markdown"]},{"title":"Hello World","url":"/2024/09/05/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]