[{"title":"基于VirtualBox虚拟机安装Ubuntu教程","url":"/2024/10/17/基于VirtualBox虚拟机安装Ubuntu教程/","content":"## 下载安装VirtualBox\n官网下载VirtualBox，目前版本：VirtualBox 5.1.8 for Windows hosts x86/amd64\n下载好了安装VirtualBox，一路Next就可以了,这个比较简单。\n运行VirtulBox程序, 如下图：\n配置VirtualBox。按 CTRL+G打开全局设定，根据需要可以设定虚拟脑位置和界面语言：\n\n修改默认虚拟脑位置比如D:\\myvbvms可以让自己更方便的查找，备份安装好的虚拟机。\n## 安装 Ubuntu\n### 创建虚拟机\n1. 运行VirtulBox程序，点击“新建”按钮，新建一个虚拟机。\n2. 虚拟机名称可以随意输入，示例：rocedu。操作系统选择Linux，版本选择ubuntu。点击“下一步”。\n3. 设定虚拟机的内存，此内存即为虚拟机所占用的系统内存，可随意修改，建议不要超过系统内存的1/2。\n首先了解自己的笔记本电脑系统内存大小，“我的电脑”->“属性”。样机为16G。\n为了方便以后编程学习使用，这里将虚拟内存设为4G。点击“下一步”。\n4. 为虚拟机创建一块虚拟硬盘。选择“现在创建虚拟硬盘”，并单击“创建”。\n### 安装 Ubuntu 系统软件\n在虚拟机上安装Ubuntu和在真实机器上安装没有大的差别。\n","tags":["教程","Ubuntu"]},{"title":"MiniMIPS32","url":"/2024/10/12/MiniMIPS32/","content":"## 指令集仿真器 -- TEMU\n### 实验简介\n采用高级语言（C/C++、Java或Python等）设计面向32位MIPS或LoongArch指令集子集的指令集仿真器 -- TEMU，用于实现对程序执行过程的模拟和调试。该指令集仿真器可模拟常见指令，支持单步执行、断点、显示寄存器信息、显示特定存储单元信息等功能，为后续的处理器设计实验提供仿真测试工具。","tags":["MiniMIPS32"]},{"title":"数值计算方法","url":"/2024/10/08/数值计算方法/","content":"## 插值法\n**实现范德蒙德多项式插值、拉格朗日插值、牛顿插值、分段线性、分段三次 Hermite 插值，并完成各方法之间的对比。**\n<font color=red>输入</font>：插值区间 $[a, b]$，参数 $c, d, e, f$ 作为标准函数 $f(x) = c \\cdot \\sin dx + e \\cdot \\cos fx$ 的值，参数 $n+1$ 作为采样点的个数，参数 $m$ 作为实验点的个数。\n<font color=red>要求</font>：在区间 $[a, b]$ 上均匀采集个采集点，利用这 $n+1$ 个采集点，分别使用范德蒙德多项式插值、拉格朗日插值、牛顿插值、分段线性、分段三次 Hermite 插值进行插值，求出 $L(x)$，之后再选取 $m$ 个点作为实验点，计算在这 $m$ 个实验点上插值函数 $L(x)$ 与目标函数 $f(x)$ 的平均误差。同时对比各插值方法之间的精度差异。\n<font color=red>输出</font>：对比函数曲线，平均误差。\n```Python\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# 范德蒙德多项式插值\ndef vandermonde_interpolation(x, y, x_values):\n    n = len(x)\n    coefficients = []\n    c = []\n    for i in range(n):\n        coeff = []\n        for j in range(n):\n            coeff.append(x[i]**j)\n        coefficients.append(coeff)\n        c.append(y[i])\n    A = np.array(coefficients)\n    inv_A = np.linalg.inv(A)\n    a = inv_A.dot(c)\n    sum = 0\n    for i in range(n):\n        sum += a[i] * x_values ** i\n    return sum\n\n# 拉格朗日插值\ndef lagrange_interpolation(x, y, x_values):\n    n = len(x)\n    result = 0\n    for i in range(n):\n        p = y[i]\n        for j in range(n):\n            if j != i:\n                p *= (x_values - x[j]) / (x[i] - x[j])\n        result += p\n    return result\n\n# 牛顿插值\ndef newton_interpolation(x, y, x_values):\n    n = len(x)\n    coefficients = []\n    for i in range(n-1, 0, -1):\n        divided_diff = (y[i] - y[i-1]) / (x[i] - x[i-1])\n        coefficients.append(divided_diff)\n        for j in range(n-i-1, 0, -1):\n            divided_diff = (-divided_diff + coefficients[j-1]) / (x[n-j] - x[i-1])\n            coefficients[j-1] = divided_diff\n    coefficients.append(y[0])\n    result = coefficients[0]\n    for i in range(n-2, -1, -1):\n        result = result * (x_values - x[i]) + coefficients[n-1-i]\n    return result\n\n# 分段线性插值\ndef piecewise_linear_interpolation(x, y, x_values):\n    n = len(x)\n    result = 0\n    for i in range(n-1):\n        mask = (x[i] <= x_values) & (x_values < x[i+1])\n        slope = (y[i+1] - y[i]) / (x[i+1] - x[i])\n        result += ((y[i] + slope * (x_values - x[i]))*mask)\n    if (x_values == x[n-1]):\n        result = y[n-1]\n    return result\n\n# 分段三次Hermite插值\ndef piecewise_cubic_hermite_interpolation(x, y, yy, x_values):\n    n = len(x)\n    result = 0\n    for i in range(n-1):\n        if ((x[i] <= x_values) & (x_values < x[i+1])):\n            ai = (1+2*(x_values-x[i])/(x[i+1]-x[i]))*((x_values-x[i+1])/(x[i]-x[i+1]))**2\n            bi = (x_values - x[i])*((x_values-x[i+1])/(x[i]-x[i+1]))**2\n            ai1 = (1+2*(x_values-x[i+1])/(x[i]-x[i+1]))*((x_values-x[i])/(x[i+1]-x[i]))**2\n            bi1 = (x_values - x[i+1])*((x_values-x[i])/(x[i+1]-x[i]))**2\n            result += (y[i] * ai +yy[i] * bi +y[i+1] * ai1 +yy[i+1] * bi1)\n    if (x_values == x[n-1]):\n        result = y[n-1]\n    return result\n\n# 目标函数\ndef target_function(c,d,e,f,x):\n    return [(c*np.sin(d*val)+e*np.cos(f*val)) for val in x] \n\n# 目标函数导函数\ndef derivative_function(c,d,e,f,x):\n    return [(c*d*np.cos(d*val)-e*f*np.sin(f*val)) for val in x]\n\n# 计算平均误差\ndef compute_average_error(f, g, x_values):\n    return sum([abs(f[i] - g[i]) for i in range(len(x_values))]) / len(x_values)\n\n# 设置插值区间和参数\na = float(input())\nb = float(input())\nc = float(input())\nd = float(input())\ne = float(input())\nf = float(input())\nnum_samples = int(input())\nnum_experiments = int(input())\nx_values = [a + (b - a) * i / (num_samples - 1) for i in range(num_samples)]\nys = target_function(c,d,e,f,x_values)\nyy = derivative_function(c,d,e,f,x_values)\n\n# 计算实验点\nexperiment_points = [a + (b - a) * i / (num_experiments - 1) for i in range(num_experiments)]\n\n# 计算各插值方法的插值结果和平均误差\nvandermonde_interpolated = [vandermonde_interpolation(x_values, ys, val) for val in experiment_points]\nvandermonde_error = compute_average_error(target_function(c,d,e,f,experiment_points), vandermonde_interpolated, experiment_points)\n\nlagrange_interpolated = [lagrange_interpolation(x_values, ys, val) for val in experiment_points]\nlagrange_error = compute_average_error(target_function(c,d,e,f,experiment_points), lagrange_interpolated, experiment_points)\n\nnewton_interpolated = [newton_interpolation(x_values, ys, val) for val in experiment_points]\nnewton_error = compute_average_error(target_function(c,d,e,f,experiment_points), newton_interpolated, experiment_points)\n\npiecewise_linear_interpolated = [piecewise_linear_interpolation(x_values, ys, val) for val in experiment_points]\npiecewise_linear_error = compute_average_error(target_function(c,d,e,f,experiment_points), piecewise_linear_interpolated, experiment_points)\n\npiecewise_cubic_hermite_interpolated = [piecewise_cubic_hermite_interpolation(x_values, ys, yy, val) for val in experiment_points]\npiecewise_cubic_hermite_error = compute_average_error(target_function(c,d,e,f,experiment_points), piecewise_cubic_hermite_interpolated, experiment_points)\n\nfig = plt.figure(num = 1,dpi = 120)\nax = plt.subplot(1,1,1)\n # 坐标轴\nax = plt.gca()  # get current axis 获得坐标轴对象\nax.spines['right'].set_color('none')  # 将右边 边沿线颜色设置为空 其实就相当于抹掉这条边\nax.spines['top'].set_color('none')\nax.xaxis.set_ticks_position('bottom')\nax.yaxis.set_ticks_position('left')\n# 设置中心的为（0，0）的坐标轴\nax.spines['bottom'].set_position(('data', 0))  # 指定 data 设置的bottom(也就是指定的x轴)绑定到y轴的0这个点上\nax.spines['left'].set_position(('data', 0))\n\nx=list(np.arange(a,b,0.01))#此处可调整自变量取值范围，以便选择合适的观察尺度\ny=[]\ny1=[]\ny2=[]\ny3=[]\ny4=[]\ny5=[]\nfor i in range(len(x)):\n    y = target_function(c,d,e,f,x)\n    y1.append(vandermonde_interpolation(x_values, ys, x[i]))\n    y2.append(lagrange_interpolation(x_values, ys, x[i]))\n    y3.append(newton_interpolation(x_values, ys, x[i]))\n    y4.append(piecewise_linear_interpolation(x_values, ys, x[i]))\n    y5.append(piecewise_cubic_hermite_interpolation(x_values, ys, yy, x[i]))\n    \n\nax.plot(x,y,label = \"Target Function\",color =\"blueviolet\")\nax.plot(x_values,ys, marker = \"*\",linestyle = \"\", color = \"blueviolet\")\nax.plot(x,y1,label = \"vandermonde interpolation\\n average error=%f\"%vandermonde_error,color =\"red\")\nax.plot(experiment_points, vandermonde_interpolated, marker = \"o\",linestyle = \"\", color = \"red\")\nax.plot(x,y2,label = \"lagrange interpolation\\n average error=%f\"%lagrange_error,color =\"yellow\")\nax.plot(experiment_points, lagrange_interpolated, marker = \"o\",linestyle = \"\", color = \"yellow\")\nax.plot(x,y3,label = \"newton interpolation\\n average error=%f\"%newton_error,color =\"green\")\nax.plot(experiment_points, newton_interpolated, marker = \"o\",linestyle = \"\", color = \"green\")\nax.plot(x,y4,label = \"piecewise linear interpolation\\n average error=%f\"%piecewise_linear_error,color =\"blue\")\nax.plot(experiment_points, piecewise_linear_interpolated, marker = \"o\",linestyle = \"\", color = \"blue\")\nax.plot(x,y5,label = \"piecewise cubic hermite interpolation\\n average error=%f\"%piecewise_cubic_hermite_error,color =\"purple\")\nax.plot(experiment_points, piecewise_cubic_hermite_interpolated, marker = \"o\",linestyle = \"\", color = \"purple\")\n#ax.set_xlim(0,2)\n#plt.draw()\nplt.legend()\nplt.show()\n```\n\n## 函数逼近\n**实现最佳平方逼近与最小二乘拟合，并完成两种方法之间的对比。**\n<font color=red>输入</font>：函数区间 $[a, b]$，参数 $c$ 作为标准函数$f(x)=\\frac{1}{1+cx^2}$的值，参数 $k$ 作为所构造的逼近多项式的次数 $(k=1,2,3)$ 。参数 $n+1$ 作为采样点的个数，参数 $m$ 作为实验点的个数。\n<font color=red>要求</font>：要求选用勒让德正交多项式作最佳平方逼近；在区间 $[a, b]$ 上均匀采集 $n$ 个采集点，利用这 $n+1$ 个采集点，计算采集点上的函数值，构造最小二乘拟合多项式函数。之后再选取 $m$ 个点作为实验点，计算在这 $m$ 个实验点上所构造的逼近函数与给定的目标函数 $f(x)$ 的平均误差。同时对比两种逼近方法之间的精度差异。\n<font color=red>输出</font>：对比函数曲线，平均误差。\n```Python\nfrom sympy import *\nimport matplotlib.pyplot as plt\nimport numpy as np\nplt.rcParams['font.sans-serif']=['SimHei']\nplt.rcParams['axes.unicode_minus'] = False\ndef qpow(a,n):\n    ans=1\n    while n!=0:\n        if n&1:\n            ans*=a\n        a*=a\n        n>>=1\n    return ans\ndef F(x):\n    res = 1/(1+c*x*x)\n    return res\ndef cntpf():\n    t = symbols('t')\n    # (b-a)*t/2+(b+a)/2\n    fp[0] = integrate(1 / (1 + c * ((b - a) * t / 2 + (b + a) / 2) * ((b - a) * t / 2 + (b + a) / 2)),(t, -1, 1)).evalf()\n    fp[1] = integrate((1 / (1 + c * ((b - a) * t / 2 + (b + a) / 2) * ((b - a) * t / 2 + (b + a) / 2))) * (t),(t, -1, 1)).evalf()\n    fp[2] = integrate((1 / (1 + c * ((b - a) * t / 2 + (b + a) / 2) * ((b - a) * t / 2 + (b + a) / 2))) * (3 * t * t / 2 - 1 / 2),(t, -1, 1)).evalf()\n    fp[3] = integrate((1 / (1 + c * ((b - a) * t / 2 + (b + a) / 2) * ((b - a) * t / 2 + (b + a) / 2))) * (5 * t * t * t / 2 - 3 * t / 2),(t, -1, 1)).evalf()\ndef bsa(inp):\n    res=0\n    inp =(2 * inp -a - b) / (b - a)\n    for i in range(0,k):\n        res+=(2*i+1)*fp[i]*qpow(inp,i)/2\n    return res\ndef setup():\n    for i in range(0,100):\n        vispa[i]=0\n        vispb[i]=0\ndef initx():\n    d=(b-a)/n\n    x[0]=a\n    for i in range(1,n):\n        x[i]=x[i-1]+d\ndef compa(i):\n    if vispa[i]==1:\n        return  pa[i]\n    up=0\n    down=0\n    for j in range(0,n):\n        up+=comP(i-1,x[j])*comP(i-1,x[j])*x[j]\n        down += comP(i - 1, x[j]) * comP(i - 1, x[j])\n    res=up/down\n    vispa[i] = 1\n    pa[i] = res\n    return res\ndef compb(i):\n    if vispb[i]==1:\n        return pb[i]\n    up = 0\n    down = 0\n    for j in range(0, n):\n        up += comP(i, x[j]) * comP(i, x[j])\n        down += comP(i - 1, x[j]) * comP(i - 1, x[j])\n    res=up/down\n    vispb[i] = 1\n    pb[i] = res\n    return res\ndef comP(i,inp):\n    res=0\n    if i==0:\n        res=1\n    elif i==1:\n        res = (inp -compa(1))*comP(0, inp)\n    else:\n        res = (inp -compa(i))*comP(i - 1, inp)-compb(i - 1) * comP(i - 2, inp)\n\n    return res\ndef lsf(inp):\n    initx()\n    res=0\n    for i in range(0,k):\n        up=0\n        down=0\n        for j in range(0,n):\n            up += F(x[j]) * comP(i, x[j])\n            down += comP(i, x[j]) * comP(i, x[j])\n        res += comP(i, inp)*up / down\n    return res\ndef bsaerror(inp):\n    return abs(bsa(inp)-F(inp))\ndef lsferror(inp):\n    return abs(lsf(inp)-F(inp))\n\n#全局变量\nx=[None]*200\nfp=[None]*50\nvispa=[0]*100\nvispb=[0]*100\npa=[None]*200\npb=[None]*200\n\n#主函数段\na, b, c = map(int, input(\"输入a,b,c: \").split())\nn , k = map(int, input(\"输入n,k: \").split())\nm=input(\"请输入测试组数：\")\ntst = input(\"请输入测试用例：\").split()\n\nsetup() #初始化fp数组\ncntpf() #初始化fp数组\n\nbsax=range(int(a),int(b))\nbsay=[]\nbsae=0\nfor i in bsax:\n    bsay.append(bsa(i))\n    \nlsfx=range(int(a),int(b))\nlsfy=[]\nlsfe=0\nfor i in lsfx:\n    lsfy.append(lsf(i))\n    \nnx=range(int(a),int(b))\nny=[]\nfor i in nx:\n    ny.append(F(i))\n    \nfor i in tst:\n    bsae+=bsaerror(float(i))\n    lsfe+=lsferror(float(i))\nbsae/=float(m)\nlsfe/=float(m)\nprint('最佳平方逼近的平均误差为%f'%bsae)\nprint('最小二乘拟合的平均误差为%f'%lsfe)\nplt.plot(bsax, bsay, label='最佳平方逼近', color='red')\nplt.plot(lsfx, lsfy, label='最小二乘拟合', color='blue')\nplt.plot(nx, ny, label='原函数', color='orange')\nplt.legend()\nplt.title('函数逼近对比函数')\nplt.xlabel('x')\nplt.ylabel('y')\nplt.show()\n```\n\n## 数值积分\n**实现复化梯形公式和龙贝格算法计算积分，并完成两种方法之间的精度对比。**\n<font color=red>输入</font>：函数区间 $[a, b]$，被积函数为 $f(x) =\\sqrt{x}lnx$，参数 $h$ 作为步长。参数 $ε$ 作为要求满足的精度条件。\n<font color=red>要求</font>：取不同的步长 $h$，要求用复化梯形公式和龙贝格算法分别计算积分值计算当精度达到 $ε$ 时，所需要等分积分区间的次数（假设每次都是二等分）及 $h$ 的大小。当达到精度要求时，对比两种方法需要划分次数及步长 $h$ 的大小。\n<font color=red>输出</font>：数值积分计算结果，划分次数，步长 $h$ 的大小。\n```Python\nimport math\n#初始化变量\nvis = [[0 for i in range(1000)] for j in range(1000)]\nT = [[0 for i in range(1000)] for j in range(1000)]\n\ndef f(x):\n    res=math.sqrt(x)*math.log(x,math.e)\n    return res\n\ndef F(x):\n    x3=x*x*x\n    res=2*math.log(x,math.e)*math.sqrt(x3)/3-4*math.sqrt(x3)/9\n    return res\n\n#使用牛顿莱布尼茨公式直接积分\ndef Fitg(a,b):\n    res=F(b)-F(a)\n    return  res\n\n#使用复合梯形求积公式直接积分\ndef ctqf(n):\n    h=(b-a)/n\n    res=0\n    for k in range(n):\n        res+=f(a+k*h)+f(a+(k+1)*h)\n    res=res*h/2\n    return res\n\n#计算T的值\ndef cntT(m,k):\n    if(vis[m][k]==1):\n        return T[m][k]\n    else:\n        vis[m][k] == 1\n        if(m==0 and k==0):\n            T[m][k]=(b-a)*(f(a)+f(b))/2\n        elif(m==0):\n            n=1<<(k-1)\n            h=(b-a)/n\n            sm=0\n            for i in range(n):\n                sm+=f(a+(2*i+1)*h/2)\n            sm=sm*h/2\n            T[m][k]=cntT(m,k-1)/2+sm\n        else:\n            fourm=math.pow(4,m)\n            T[m][k]=fourm*cntT(m-1,k+1)/(fourm-1)-cntT(m-1,k)/(fourm-1)\n    return T[m][k]\n\n#使用龙贝格积分求积\ndef Romberg(m):\n    return cntT(m,0)\n\na,b =map(float,input(\"请输入积分区间a,b: \").split())\ne=float(input(\"请输入精度条件e: \"))\n\nfor k in range(1000):\n    n=1<<k\n    eps=abs(ctqf(n)-Fitg(a,b))\n    if(eps<e):\n        h=(b-a)/n\n        print('复合梯形求积公式的计算结果为：%f'%(ctqf(n)))\n        print('划分次数为：%d'%(k))\n        print('步长为：%f' % (h))\n        break\n\nfor k in range(1,1000):\n    n=1<<k\n    eps=abs(Romberg(k)-Romberg(k-1))\n    if(eps<e):\n        h=(b-a)/n\n        print('龙贝格求积公式的计算结果为：%f'%(Romberg(k)))\n        print('划分次数为：%d'%(k))\n        print('步长为：%f' % (h))\n        break\n```","tags":["数值计算方法","实验记录","Python"]},{"title":"图论算法做题总结","url":"/2024/10/07/图论算法做题总结/"},{"title":"单调栈做题总结","url":"/2024/10/06/单调栈做题总结/","content":"# 基础\n## 每日温度\n```C++\n/***** 找后面第一个大 *****/\nclass Solution {\npublic:\n    vector<int> dailyTemperatures(vector<int>& temperatures) {\n        int n=temperatures.size();\n        vector<int> ans(n);\n        \n        stack<int> s;\n        for(int i=0;i<n;i++){\n            while(!s.empty()&&temperatures[s.top()]<temperatures[i]){ //栈中维护下标写法\n                ans[s.top()]=i-s.top();\n                s.pop();\n            }\n            s.push(i);\n        }\n \n        return ans;\n    }\n};\n```\n## 商品折扣后的最终价格\n```C++\n/***** 找后面第一个小于等于 *****/\nclass Solution {\npublic:\n    vector<int> finalPrices(vector<int>& prices) {\n        int n=prices.size();\n        vector<int> ans(n);\n \n        stack<int> s;\n        for(int i=0;i<n;i++){\n            while(!s.empty()&&prices[s.top()]>=prices[i]){\n                ans[s.top()]=prices[s.top()]-prices[i];\n                s.pop();\n            }\n            s.push(i);\n        }\n        \n        while(!s.empty()){\n            ans[s.top()]=prices[s.top()];\n            s.pop();\n        }\n        return ans;\n    }\n};\n```\n## 下一个更大元素 I\n```C++\n/***** 找后面第一个大 *****/\nclass Solution {\npublic:\n    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {\n        vector<int> ans(nums1.size());\n        unordered_map<int,int> hashmap;\n        \n        //处理nums2\n        stack<int> s;\n        for(int i=0;i<nums2.size();i++){\n            while(!s.empty()&&nums2[s.top()]<nums2[i]){\n                int temp=nums2[s.top()];\n                hashmap[temp]=nums2[i];\n                s.pop();\n            }\n            s.push(i);\n        }\n \n        for(int i=0;i<nums1.size();i++){\n            int temp=nums1[i];\n            if(hashmap[temp]) ans[i]=hashmap[temp];\n            else ans[i]=-1;\n        }\n        return ans;\n    }\n};\n```\n## 下一个更大元素 II\n```C++\n/***** 循环找后面第一个大 *****/\nclass Solution {\npublic:\n    vector<int> nextGreaterElements(vector<int>& nums) {\n        int n=nums.size();\n        vector<int> ans(n,-1);\n \n        stack<int> s;\n        for(int i=0;i<2*n-1;i++){\n            while(!s.empty()&&nums[s.top()]<nums[i%n]){\n                ans[s.top()]=nums[i%n];\n                s.pop();\n            }\n            s.push(i%n);\n        }\n        \n        return ans;\n    }\n};\n```\n## 最大宽度坡\n```C++\n/*单调递减栈*/\nclass Solution {\npublic:\n    int maxWidthRamp(vector<int>& nums) {\n        stack<int> s;\n        int n = nums.size();\n        for (int i = 0;i < n;i++) {\n            if (s.empty() || nums[s.top()] > nums[i]) {//要把第一个数据push\n                s.push(i);\n            }\n        }\n        int ans = 0;\n        for (int i = n - 1;i >= 0;i--) {\n            while (!s.empty() && nums[s.top()]<=nums[i]) {\n                ans = max(ans,i - s.top());\n                s.pop();\n            }\n        }\n        return ans;\n    }\n};\n```\n## 车队\n```C++\n/***** 排序+单调栈 *****/\n/***** 根据位置由小到大排序，位置大的左侧（位置小）的时间不应更小等->（严格）单调递减栈 *****/\nclass Solution {\npublic:\n    int carFleet(int target, vector<int>& position, vector<int>& speed) {\n        map<int,int> ps; //自动排序\n        for(int i=0;i<position.size();i++){\n            ps[position[i]]=speed[i];\n        }\n\n        stack<double> s;\n        for(auto& [pos,spd]:ps){\n            double time=double(target-pos)/spd;\n            while(!s.empty()&&s.top()<=time){\n                s.pop();\n            }\n            s.push(time);\n        }\n        return s.size();\n    }\n};\n```\n# 矩形面积（完结）\n## 柱状图中最大的矩形\n```C++\n/***** 单调栈的其中一种写法---处理栈中元素 *****/\nclass Solution {\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        int n = heights.size();\n        vector<int> left(n,-1), right(n,n); //左边第一个小的位置、右边第一个小的位置\n        \n        stack<int> s;\n        for(int i=0;i<n;i++){ //处理右边\n\t\t\twhile(!s.empty()&&heights[s.top()]>heights[i]){\n\t\t\t\tright[s.top()]=i;\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t\ts.push(i);\n\t\t}\n \n        s = stack<int> (); //清空栈\n        for(int i=n-1;i>=0;i--){ //处理左边\n\t\t\twhile(!s.empty()&&heights[s.top()]>heights[i]){\n\t\t\t\tleft[s.top()]=i;\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t\ts.push(i);\n\t\t}\n        \n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            ans = max(ans, (right[i] - left[i] - 1) * heights[i]);\n        }\n        return ans;\n    }\n};\n```\n## 好子数组的最大分数\n```C++\n/***** 单调栈的另一种写法---处理当前元素 *****/\nclass Solution {\npublic:\n    int maximumScore(vector<int>& nums, int k) {\n        int n=nums.size();\n        vector<int> left(n,-1),right(n,n); //左边第一小的编号、右边第一小的编号\n \n        stack<int> s;\n        for(int i=0;i<n;i++){ //处理左边\n            while(!s.empty()&&nums[s.top()]>=nums[i]) s.pop();\n            if(!s.empty()) left[i]=s.top();\n            s.push(i);\n        }\n \n        s=stack<int> ();\n        for(int i=n-1;i>=0;i--){ //处理右边\n            while(!s.empty()&&nums[s.top()]>=nums[i]) s.pop();\n            if(!s.empty()) right[i]=s.top();\n            s.push(i);\n        }\n        \n        int ans=0;\n        for(int i=0;i<n;i++){\n            int h=nums[i],l=left[i],r=right[i];\n            if(l<k&&r>k){ //多了一个区间判断\n                ans=max(ans,h*(r-l-1));\n            }\n        }\n        return ans;\n    }   \n};\n```\n## 最大矩形\n```C++\nclass Solution {\npublic:\n    int maximalRectangle(vector<vector<char>>& matrix) {\n        int n=matrix.size(); //行数\n        int m=matrix[0].size(); //列数\n        vector<vector<int>> left(n,vector<int>(m,0));\n        for(int i=0;i<n;i++){\n            for(int j=0;j<m;j++){\n                if(matrix[i][j]=='1'){\n                    left[i][j]=(j==0?1:left[i][j-1]+1); //往左能够延申的最大长度\n                }\n            }\n        }\n        int ret=0;\n \n        //对于每一列，使用基于柱状图求最大矩形的方法\n        for(int j=0;j<m;j++){\n            vector<int> up(n,0),down(n,0);\n \n            stack<int> s;\n            for(int i=0;i<n;i++){ \n                while(!s.empty()&&left[s.top()][j]>=left[i][j]){\n                    s.pop();\n                }\n                up[i]=s.empty()?-1:s.top(); //上边第一个小于的编号\n                s.push(i);\n            }\n            s=stack<int>();//清空栈\n            for(int i=n-1;i>=0;i--){\n                while(!s.empty()&&left[s.top()][j]>=left[i][j]){\n                    s.pop();\n                }\n                down[i]=s.empty()?n:s.top(); //下边第一个小于的编号\n                s.push(i);\n            }\n            \n            for(int i=0;i<n;i++){\n                int width=down[i]-up[i]-1;\n                int area=width*left[i][j];\n                ret=max(ret,area);\n            }\n        }\n \n        return ret;\n    }\n};\n```\n## 统计全 1 子矩形\n```C++\nclass Solution {\npublic:\n    int numSubmat(vector<vector<int>>& mat) {\n        int n=mat.size();\n        int m=mat[0].size();\n        vector<int> height(m);\n \n        /*单调栈求左右更小值(同时处理)*/\n        auto calc=[&]()->int{\n            vector<int> left(m,-1),right(m,m);\n \n            stack<int> s;\n            for(int i=0;i<m;i++){\n                while(!s.empty()&&height[s.top()]>height[i]){\n                    right[s.top()]=i;\n                    s.pop();\n                }\n                if(!s.empty()){\n                    left[i]=s.top();\n                }\n                s.push(i);\n            }\n \n            int ans=0;\n            /* 计算结果时, 乘法原理 * 矩阵高度 */\n            for(int i=0;i<m;i++){\n                ans+=(right[i]-i)*(i-left[i])*height[i];\n            }\n            return ans;\n        };\n \n        int ans=0;\n        for(int i=0;i<n;i++){ /* 遍历每一行的高度, 更新改行的高度值使用单调栈计算左侧更小值和右侧更小值,再计算每个小矩阵出现的次数*/\n            for(int j=0;j<m;j++){\n                if(mat[i][j]==0){\n                    height[j]=0;\n                }\n                else{\n                    height[j]++;\n                }\n            }\n            ans+=calc();\n        }\n        return ans;\n    }\n};\n```\n## 接雨水\n```C++\nclass Solution {\npublic:\n    int trap(vector<int>& height) {\n        int ans=0;\n        int n=height.size();\n\n        stack<int> s;\n        for (int i=0;i<n;i++) {\n            while (!s.empty() && height[s.top()]<height[i]) {\n                int top = s.top();\n                s.pop();\n                if (s.empty()) {\n                    break;\n                }\n                int left = s.top();\n                int currWidth = i - left - 1;\n                int currHeight = min(height[left], height[i]) - height[top];\n                ans += currWidth * currHeight;\n            }\n            s.push(i);\n        }\n        \n        return ans;\n    }\n};\n/***** 不能单纯找左边第一个大、右边第一个大 *****/\n/*这种情况会多算\n*   *\n** **\n** **\n*****\n*/\n```\n# 最小字典序\n## 移掉 K 位数字\n","tags":["单调栈","编程","c++"]},{"title":"动态规划做题总结","url":"/2024/10/02/动态规划做题总结/","content":"# 入门 DP\n## 爬楼梯\n### 爬楼梯\n```C\nclass Solution {\npublic:\n    int climbStairs(int n) {\n        vector<int> f(n+1);     \n        f[0]=1,f[1]=1;\n        for(int i=2;i<=n;i++){\n            f[i]=f[i-1]+f[i-2];\n        }\n        return f[n];\n    }\n};\n/*由于这里的 f(x) 只和 f(x−1) 与 f(x−2) 有关，所以我们可以用「滚动数组思想」把空间复杂度优化成 O(1)*/\nclass Solution {\npublic:\n    int climbStairs(int n) {\n        int p = 0, q = 0, r = 1;\n        for (int i = 1; i <= n; i++) {\n            p = q; \n            q = r; \n            r = p + q;\n        }\n        return r;\n    }\n};\n```\n### 使用最小花费爬楼梯\n```C\nclass Solution {\npublic:\n    int minCostClimbingStairs(vector<int>& cost) {\n        int n = cost.size();\n        vector<int> dp(n + 1);\n        dp[0] = dp[1] = 0;\n        for (int i = 2; i <= n; i++) {\n            dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);\n        }\n        return dp[n];\n    }\n};\n```\n### 组合总和 Ⅳ\n```C\n/*本质是爬楼梯，相当于每次往上爬 nums[i] 步*/\nclass Solution {\npublic:\n    long long combinationSum4(vector<int>& nums, int target) {\n        vector<long long> dp(target + 1);\n        dp[0] = 1; //只有当不选取任何元素时，元素之和才为 0，因此只有 1 种方案。\n        for (int i = 1; i <= target; i++) {\n            for (int& num : nums) {\n                if (num <= i&& dp[i - num] < INT_MAX - dp[i]) {\n                    dp[i] += dp[i - num];\n                }\n            }\n        }\n        return dp[target];\n    }\n};\n/*另一种写法*/\nclass Solution {\npublic:\n    int combinationSum4(vector<int> &nums, int target) {\n        // 使用 unsigned 可以让溢出不报错\n        // 对于溢出的数据，不会影响答案的正确性（题目保证）\n        vector<unsigned> f(target + 1);\n        f[0] = 1;\n        for (int i = 1; i <= target; i++) {\n            for (int x : nums) {\n                if (x <= i) {\n                    f[i] += f[i - x];\n                }\n            }\n        }\n        return f[target];\n    }\n};\n```\n### 统计构造好字符串的方案数\n```C\nclass Solution {\npublic:\n    int countGoodStrings(int low, int high, int zero, int one) {\n        const int MOD = 1'000'000'007;\n        int ans = 0;\n        vector<int> f(high + 1); // f[i] 表示构造长为 i 的字符串的方案数\n        f[0] = 1; // 构造空串的方案数为 1\n        for (int i = 1; i <= high; i++) {\n            if (i >= zero) f[i] = f[i - zero];\n            if (i >= one)  f[i] = (f[i] + f[i - one]) % MOD;\n            if (i >= low)  ans = (ans + f[i]) % MOD;\n        }\n        return ans;\n    }\n};\n```\n### 统计打字方案数\n```C\nclass Solution {\npublic:\n    int countTexts(string pressedKeys) {\n        int m = 1000000007;\n        vector<long long> dp3 = {1, 1, 2, 4};   // 连续按多次 3 个字母按键对应的方案数\n        vector<long long> dp4 = {1, 1, 2, 4};   // 连续按多次 4 个字母按键对应的方案数\n        int n = pressedKeys.size();\n        for (int i = 4; i < n + 1; ++i) {\n            dp3.push_back((dp3[i-1] + dp3[i-2] + dp3[i-3]) % m);\n            dp4.push_back((dp4[i-1] + dp4[i-2] + dp4[i-3] + dp4[i-4]) % m);\n        }\n        long long res = 1;   // 总方案数\n        int cnt = 1;   // 当前字符连续出现的次数\n        for (int i = 1; i < n; ++i) {\n            if (pressedKeys[i] == pressedKeys[i-1]) {\n                ++cnt;\n            } else {\n                // 对按键对应字符数量讨论并更新总方案数\n                if (pressedKeys[i-1] == '7' || pressedKeys[i-1] == '9') {\n                    res *= dp4[cnt];\n                } else {\n                    res *= dp3[cnt];\n                }\n                res %= m;\n                cnt = 1;\n            }\n        }\n        // 更新最后一段连续字符子串对应的方案数\n        if (pressedKeys[n-1] == '7' || pressedKeys[n-1] == '9') {\n            res *= dp4[cnt];\n        } else {\n            res *= dp3[cnt];\n        }\n        res %= m;\n        return res;\n    }\n};\n```\n## 打家劫舍\n### 打家劫舍\n```C\n/*题意转化为：从序列中选择子序列使得它们的和最大，数不能有相邻*/\nclass Solution {\npublic:\n    int rob(vector<int>& nums) {\n        int n=nums.size();\n        if(n==1) return nums[0];\n        vector<int> dp(n,0); //用 dp[i] 表示前 i 间房屋能偷窃到的最高总金额\n        dp[0]=nums[0];\n        dp[1]=max(nums[0],nums[1]);\n        for(int i=2;i<n;i++){\n            dp[i]=max(dp[i-2]+nums[i],dp[i-1]);\n        }  \n        return dp[n-1];\n    }\n};\n/*上述方法使用了数组存储结果。考虑到每间房屋的最高总金额只和该房屋的前两间房屋的最高总金额相关，因此可以使用滚动数组，在每个时刻只需要存储前两间房屋的最高总金额。*/\nclass Solution {\npublic:\n    int rob(vector<int>& nums) {\n        int n=nums.size();\n        if(n==1) return nums[0];\n        int first=nums[0],second=max(nums[0],nums[1]);\n        for(int i=2;i<n;i++){\n            int temp=second;\n            second=max(first+nums[i],second);\n            first=temp;\n        }\n        return second;\n    }\n};\n```\n### 删除并获得点数\n```C\nclass Solution {\nprivate:\n    int rob(vector<int>& nums) {\n        int n=nums.size();\n        if(n==1) return nums[0];\n        int first=nums[0],second=max(nums[0],nums[1]);\n        for(int i=2;i<n;i++){\n            int temp=second;\n            second=max(first+nums[i],second);\n            first=temp;\n        }\n        return second;\n    }\npublic:\n    int deleteAndEarn(vector<int>& nums) {\n        int maxval=0;\n        for(int val:nums){\n            maxval=max(maxval,val);\n        }\n        vector<int>sum(maxval+1,0);\n        for(int val:nums){\n            sum[val]+=val;\n        }\n        return rob(sum);\n    }\n};\n```\n### 统计放置房子的方式数\n```C\n/*单独考虑一侧的房子，定义 f[i] 表示前 i 个地块的放置方案数，其中第 i 个地块可以放房子，也可以不放房子。*/\nconst int mod=1e9+7;\nclass Solution {\npublic:\n    int countHousePlacements(int n) {\n        vector<long long> f(n+1,0);\n        f[0]=1;\n        f[1]=2;\n        for(int i=2;i<=n;i++){\n            f[i]=(f[i-1]+f[i-2])%mod;\n        }\n        return f[n]*f[n]%mod;\n    }\n};\n```\n### 打家劫舍 II\n```C\n/*第一间房屋和最后一间房屋不同时偷窃*/\nclass Solution {\npublic:\n    int robRange(vector<int>& nums, int start, int end) {\n        int first = nums[start], second = max(nums[start], nums[start + 1]);\n        for (int i = start + 2; i <= end; i++) {\n            int temp = second;\n            second = max(first + nums[i], second);\n            first = temp;\n        }\n        return second;\n    }\n\n    int rob(vector<int>& nums) {\n        int length = nums.size();\n        if (length == 1) {\n            return nums[0];\n        } \n        else if (length == 2) {\n            return max(nums[0], nums[1]);\n        }\n        return max(robRange(nums, 0, length - 2), robRange(nums, 1, length - 1));\n    }\n};\n```\n### 施咒的最大总伤害\n## 最大子数组和\n>*定义状态 f[i] 表示以 a[i] 结尾的最大子数组和，不和 i 左边拼起来就是f[i]=a[i]，和 i 左边拼起来就是f[i]=f[i−1]+a[i]，取最大值就得到了状态转移方程 f[i]=max(f[i−1],0)+a[i]，答案为 max(f)。这个做法也叫做 Kadane 算法。*\n### 最大子数组和\n```C\n/*模板题*/\nclass Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        vector<int> dp(nums.size());\n        dp[0]=nums[0];\n        for(int i=1;i<nums.size();i++){\n            dp[i]=max(dp[i-1],0)+nums[i];\n        }\n        return ranges::max(dp);\n    }\n};\n```\n### 找到最大开销的子字符串\n```C\n/*一点转化+模板题*/\nclass Solution {\npublic:\n    int maximumCostSubstring(string s, string chars, vector<int>& vals) {\n        vector<int> m(26+1);\n        iota(m.begin(),m.end(),0);\n        for(int i=0;i<chars.size();i++){\n            m[chars[i]-'a'+1]=vals[i];\n        }\n \n        vector<int> dp(s.size());\n        dp[0]=m[s[0]-'a'+1];\n        int ans=max(0,dp[0]);\n        for(int i=1;i<s.size();i++){\n            dp[i]=max(dp[i-1],0)+m[s[i]-'a'+1];\n            ans=max(ans,dp[i]);\n        }\n        return ans;\n    }\n};\n```\n### 任意子数组和的绝对值的最大值\n```C\n/*题目转化为max(最大子数组和，-最小子数组和，0)*/\nclass Solution {\npublic:\n    int maxAbsoluteSum(vector<int>& nums) {\n        vector<int> dp(nums.size());\n        dp[0]=nums[0];\n        int ans1=dp[0];\n        for(int i=1;i<nums.size();i++){\n            dp[i]=max(dp[i-1],0)+nums[i];\n            ans1=max(ans1,dp[i]);\n        }\n \n        vector<int> dp1(nums.size());\n        dp1[0]=nums[0];\n        int ans2=dp1[0];\n        for(int i=1;i<nums.size();i++){\n            dp1[i]=min(dp1[i-1],0)+nums[i];\n            ans2=min(ans2,dp1[i]);\n        }\n        int ans=max(0,ans1);\n        ans=max(ans,-ans2);\n        return ans;\n    }\n};\n```\n### K 次串联后最大子数组之和\n```C\n/*\n考虑两种情况：\n\n1.如果k=1，那就是正常DP。\n\n2.k>1时也考虑两种情况：数组所有元素和大于0，数组所有元素和小于等于0。\n首先计算两个相接的DP也就是k=2的情况，如果数组元素和大于0，那可以看成再第一段结尾第二段开头插入k-2个正数，如果数组所有元素和为负，那k=2的情况就是最大的情况。\n*/\nclass Solution {\npublic:\n    int kConcatenationMaxSum(vector<int>& arr, int k) {\n        const int mod=1e9+7;\n        int n=arr.size();\n        long long sum=0,presum=0,result=0;\n        for(int i=0;i<n*(k>1?2:1);i++){\n            long long num=arr[i%n];\n            presum=max(presum,0ll)+num;\n            result=max(result,presum);\n            if(i<n) sum+=num;\n        }\n        if(sum>0&&k>1){\n            result=(result+sum*(k-2)%mod)%mod;\n        }\n        return result;\n    }\n};\n/*\n1.sum>0、k=2时，最大子数组和如果没有跨过两个数组，那岂不是不能在中间插入k-2个sum吗？\n反证法，反设sum>0时，如果最大子数组和没有跨过两个数组。从L到R的子数组的和最大（0<=L<=R<n-1），考虑R向右n个数(R+1到R+n)，这n个数一定是和arr的数是一样的（循环了），那么这n个数的和是sum，大于0。所以从L到R+n的子数组的和要更大，而这个子数组跨过了两个数组，与反设矛盾。所以这样做是对的。\n2.sum<=0时，为什么可以化归到k=2的情况？\n还是反证法，假设最大子数组的长度>2n，那一定包括一个完整的arr数组，那么因为sum<=0，所以拿掉这一部分，把前后拼接在一起（这样做显然是合法的），这样做结果只会更优，如此操作下去，就可以划归到k=2的情况了。\n*/\n```\n### 环形子数组的最大和\n```C\nclass Solution {\npublic:\n    int maxSubarraySumCircular(vector<int>& nums) {\n        int n=nums.size();\n        vector<int> qianmax(n); //前缀最大值\n        int presum=nums[0];\n        qianmax[0]=nums[0];\n\n        int pre=nums[0];\n        int ans=pre;\n\n        for(int i=1;i<n;i++){\n            pre=max(pre,0)+nums[i];\n            ans=max(ans,pre);\n\n            presum+=nums[i];\n            qianmax[i]=max(qianmax[i-1],presum);\n        }\n\n        int housum=0;\n        for(int i=n-1;i>0;i--){ //枚举后缀和\n            housum+=nums[i];\n            ans=max(ans,housum+qianmax[i-1]);\n        }\n        return ans;\n    }\n};\n```\n### 拼接数组的最大分数\n```C\n/*转换成最大子数组和*/\nclass Solution {\n    int solve(vector<int> &nums1, vector<int> &nums2) {\n        int sum = 0, maxSum = 0;\n        for (int i = 0, s = 0; i < nums1.size(); i++) {\n            sum += nums1[i];\n            s = max(s,0)+(nums2[i] - nums1[i]);\n            maxSum = max(maxSum, s);\n        }\n        return sum + maxSum;\n    }\n\npublic:\n    int maximumsSplicedArray(vector<int> &nums1, vector<int> &nums2) {\n        return max(solve(nums1, nums2), solve(nums2, nums1));\n    }\n};\n```\n### (扩展）乘积最大子数组\n```C\nclass Solution {\npublic:\n    int maxProduct(vector<int>& nums) {\n        vector <long> maxF(nums.begin(),nums.end()), minF(nums.begin(), nums.end());\n        for (int i = 1; i < nums.size(); i++) {\n            maxF[i] = max(maxF[i - 1] * nums[i], max((long)nums[i], minF[i - 1] * nums[i]));\n            minF[i] = min(minF[i - 1] * nums[i], min((long)nums[i], maxF[i - 1] * nums[i]));\n            if(minF[i]<INT_MIN) {\n                minF[i]=nums[i];\n            }\n        }\n        return *max_element(maxF.begin(), maxF.end());\n    }\n};\n/*优化空间*/\nclass Solution {\npublic:\n    int maxProduct(vector<int>& nums) {\n        long maxF = nums[0], minF = nums[0], ans = nums[0];\n        for (int i = 1; i < nums.size(); i++) {\n            long mx = maxF, mn = minF;\n            maxF = max(mx * nums[i], max((long)nums[i], mn * nums[i]));\n            minF = min(mn * nums[i], min((long)nums[i], mx * nums[i]));\n            if(minF<INT_MIN) {\n                minF=nums[i];\n            }\n            ans = max(maxF, ans);\n        }\n        return ans;\n    }\n};\n```\n# 网格图 DP\n## 基础\n### 珠宝的最高价值\n```C\nclass Solution {\npublic:\n    int jewelleryValue(vector<vector<int>>& frame) {\n        int n=frame.size();\n        int m=frame[0].size();\n        vector<vector<int>> f(n,vector<int>(m));\n        f[0][0]=frame[0][0];\n        for(int i=1;i<n;i++){ //处理第一列\n            f[i][0]=f[i-1][0]+frame[i][0];\n        }\n        for(int j=1;j<m;j++){ //处理第一行\n            f[0][j]=f[0][j-1]+frame[0][j];\n        }\n        for(int i=1;i<n;i++){\n            for(int j=1;j<m;j++){\n                f[i][j]=max(f[i-1][j],f[i][j-1])+frame[i][j];\n            }\n        }\n        return f[n-1][m-1];\n    }\n};\n \n/*注意到状态转移方程中，f(i,j) 只会从 f(i−1,j) 和 f(i,j−1) 转移而来，而与 f(i−2,⋯) 以及更早的状态无关，因此我们同一时刻只需要存储最后两行的状态，即使用两个长度为 n 的一位数组代替 n×m 的二维数组 f，交替地进行状态转移，减少空间复杂度。*/\nclass Solution {\npublic:\n    int jewelleryValue(vector<vector<int>>& frame) {\n        int n=frame.size();\n        int m=frame[0].size();\n        vector<vector<int>> f(2,vector<int>(m));\n        for(int i=0;i<n;i++){\n            int pos=i%2;\n            for(int j=0;j<m;j++){\n                f[pos][j]=0;\n                if(i>0) f[pos][j]=max(f[pos][j],f[1-pos][j]);\n                if(j>0) f[pos][j]=max(f[pos][j],f[pos][j-1]);\n                f[pos][j]+=frame[i][j];\n            }\n        }\n        return f[(n-1)%2][m-1];\n    }\n};\n```\n### 不同路径\n```C\nclass Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<vector<int>> f(m,vector<int>(n));\n        for(int i=0;i<m;i++) f[i][0]=1;\n        for(int j=0;j<n;j++) f[0][j]=1;\n        for(int i=1;i<m;i++){\n            for(int j=1;j<n;j++){\n                f[i][j]=f[i-1][j]+f[i][j-1];\n            }\n        }\n        return f[m-1][n-1];\n    }\n};\n/*此外，由于 f(i,j) 仅与第 i 行和第 i−1 行的状态有关，因此我们可以使用滚动数组代替代码中的二维数组，使空间复杂度降低为 O(n)。*/\nclass Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<int> f(n,1);\n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                f[j]+=f[j-1];\n            }\n        }\n        return f[n - 1];\n    }\n};\n```\n### 不同路径 II\n```C\nclass Solution {\npublic:\n    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {\n        int m=obstacleGrid.size();\n        int n=obstacleGrid[0].size();\n        vector<vector<int>> f(m,vector<int>(n));\n        for(int i=0;i<m;i++){ //处理第一列\n            if(obstacleGrid[i][0]==1){ //有障碍 \n                f[i][0]=0; \n                break; //后面都到达不了\n            }\n            else f[i][0]=1;\n        }\n        for(int j=0;j<n;j++){  //处理第一行\n            if(obstacleGrid[0][j]==1){ //有障碍\n                f[0][j]=0; \n                break; //后面都到达不了\n            }\n            else f[0][j]=1;\n        }\n        for(int i=1;i<m;i++){\n            for(int j=1;j<n;j++){\n                if(obstacleGrid[i][j]==1) f[i][j]=0;\n                else f[i][j]=f[i-1][j]+f[i][j-1];\n            }\n        }\n        return f[m-1][n-1];\n    }\n};\n```\n### 最小路径和\n```C\nclass Solution {\npublic:\n    int minPathSum(vector<vector<int>>& grid) {\n        int n=grid.size();\n        int m=grid[0].size();\n        vector<vector<int>> dp(n,vector<int>(m));\n        dp[0][0]=grid[0][0];\n        for(int i=1;i<n;i++) dp[i][0]=dp[i-1][0]+grid[i][0];\n        for(int j=1;j<m;j++) dp[0][j]=dp[0][j-1]+grid[0][j];\n        for(int i=1;i<n;i++){\n            for(int j=1;j<m;j++){\n                dp[i][j]=min(dp[i-1][j],dp[i][j-1])+grid[i][j];\n            }\n        }\n        return dp[n-1][m-1];\n    }\n};\n```\n### 三角形最小路径和\n```C\nclass Solution {\npublic:\n    int minimumTotal(vector<vector<int>>& triangle) {\n        int n=triangle.size();\n        vector<vector<int>> dp(n,vector<int>(n));\n        dp[0][0]=triangle[0][0];\n        for(int i=1;i<n;i++){\n            dp[i][0]=dp[i-1][0]+triangle[i][0]; //第一列只能从上面转移\n            for(int j=1;j<i;j++){\n                dp[i][j]=min(dp[i-1][j-1],dp[i-1][j])+triangle[i][j];\n            }\n            dp[i][i]=dp[i-1][i-1]+triangle[i][i];//最后一列只能从左上转移\n        }\n        return *min_element(dp[n-1].begin(),dp[n-1].end());\n    }\n};\n/*可以发现，dp[i][j] 只与 dp[i−1][..] 有关，而与 dp[i−2][..] 及之前的状态无关，因此我们不必存储这些无关的状态。具体地，我们使用两个长度为 n 的一维数组进行转移，将 i 根据奇偶性映射到其中一个一维数组，那么 i−1 就映射到了另一个一维数组。这样我们使用这两个一维数组，交替地进行状态转移。*/\nclass Solution {\npublic:\n    int minimumTotal(vector<vector<int>>& triangle) {\n        int n=triangle.size();\n        vector<vector<int>> dp(2,vector<int>(n));\n        dp[0][0]=triangle[0][0];\n        for(int i=1;i<n;i++){\n            int cur=i%2; //当前行\n            int pre=1-cur; //上一行\n            dp[cur][0]=dp[pre][0]+triangle[i][0]; //第一列只能从上面转移\n            for(int j=1;j<i;j++){\n                dp[cur][j]=min(dp[pre][j-1],dp[pre][j])+triangle[i][j];\n            }\n            dp[cur][i]=dp[pre][i-1]+triangle[i][i];//最后一列只能从左上转移\n        }\n        return *min_element(dp[(n-1)%2].begin(),dp[(n-1)%2].end());\n    }\n};\n```\n### 下降路径最小和\n```C\nclass Solution {\npublic:\n    int minFallingPathSum(vector<vector<int>>& matrix) {\n        int n=matrix.size();\n        vector<vector<int>> dp(n,vector<int>(n));\n        copy(matrix[0].begin(),matrix[0].end(),dp[0].begin());\n        for(int i=1;i<n;i++){\n            for(int j=0;j<n;j++){\n                int minn=dp[i-1][j]; //都能从正上方转移\n                if(j>0){ //可以从左上方转移\n                    minn=min(minn,dp[i-1][j-1]);\n                }\n                if(j<n-1){ //可以从右上方转移\n                    minn=min(minn,dp[i-1][j+1]);\n                }\n                dp[i][j]=minn+matrix[i][j];\n            }\n        }\n        return *min_element(dp[n-1].begin(),dp[n-1].end());\n    }\n};\n```\n### 矩阵中移动的最大次数\n```C\nclass Solution {\npublic:\n    int maxMoves(vector<vector<int>>& grid) {\n        int ans=0; bool flag=1;\n        int n=grid.size();\n        int m=grid[0].size();\n        vector<vector<int>> dp(n,vector<int>(m)); //dp[i][j]==1表示(i,j)位置可到达\n        for(int i=0;i<n;i++) dp[i][0]=1; \n        for(int j=1;j<m;j++){\n            if(!flag) return ans;\n            flag=0;\n            for(int i=0;i<n;i++){\n                if(grid[i][j-1]<grid[i][j]&&dp[i][j-1]){\n                    dp[i][j]=1;\n                }\n                if(i>0){\n                    if(grid[i-1][j-1]<grid[i][j]&&dp[i-1][j-1]){\n                        dp[i][j]=1;\n                    }\n                }\n                if(i<n-1){\n                    if(grid[i+1][j-1]<grid[i][j]&&dp[i+1][j-1]){\n                        dp[i][j]=1;\n                    }\n                }\n                if(dp[i][j]){\n                    flag=1;\n                    ans=j;\n                }\n            }\n        }\n        //ans+=1;\n        return ans;\n    }\n};\n```\n### 网格中的最小路径代价\n```C\nclass Solution {\npublic:\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\n        int m=grid.size(),n=grid[0].size();\n        vector<vector<int>> dp(2,vector<int>(n));\n        dp[0]=grid[0];\n        for(int i=1;i<m;i++){\n            int cur=i%2; //当前行\n            int pre=1-cur; //上一行\n            for(int j=0;j<n;j++){ //当前行每一列\n                dp[cur][j]=INT_MAX;\n                for(int k=0;k<n;k++){ //上一行每一列\n                    dp[cur][j]=min(dp[cur][j],dp[pre][k]+moveCost[grid[i-1][k]][j]+grid[i][j]);\n                }\n            }\n        }\n        return *min_element(dp[(m-1)%2].begin(),dp[(m-1)%2].end());\n    }\n};\n```\n### 下降路径最小和 II\n```C\nclass Solution {\npublic:\n    int minFallingPathSum(vector<vector<int>>& grid) {\n        int n=grid.size(),m=grid[0].size();\n        vector<vector<int>> dp(2,vector<int>(m));\n        dp[0]=grid[0];\n        for(int i=1;i<n;i++){ \n            int cur=i%2; //当前行\n            int pre=1-cur; //上一行\n            for(int j=0;j<m;j++){ //当前行每一列\n                dp[cur][j]=INT_MAX;\n                for(int k=0;k<m;k++){ //上一行每一列\n                    if(j!=k){\n                        dp[cur][j]=min(dp[cur][j],dp[pre][k]+grid[i][j]);\n                    }\n                }\n            }\n        }\n        return *min_element(dp[(n-1)%2].begin(),dp[(n-1)%2].end());\n    }\n};\n```\n## 进阶\n### 矩阵的最大非负积\n```C\nclass Solution {\npublic:\n    int maxProductPath(vector<vector<int>>& grid) {\n        const int mod=1e9+7;\n        int m=grid.size(),n=grid[0].size();\n        vector<vector<long long>> maxgt(m,vector<long long>(n));\n        vector<vector<long long>> minlt(m,vector<long long>(n));\n        maxgt[0][0]=minlt[0][0]=grid[0][0];\n        for(int j=1;j<n;j++){ //处理第一行\n            maxgt[0][j]=minlt[0][j]=maxgt[0][j-1]*grid[0][j];\n        }\n        for(int i=1;i<m;i++){ //处理第一列\n            maxgt[i][0]=minlt[i][0]=maxgt[i-1][0]*grid[i][0];\n        }\n        for(int i=1;i<m;i++){\n            for(int j=1;j<n;j++){\n                if(grid[i][j]>=0){\n                    maxgt[i][j]=max(maxgt[i-1][j],maxgt[i][j-1])*grid[i][j];\n                    minlt[i][j]=min(minlt[i-1][j],minlt[i][j-1])*grid[i][j];\n                }\n                else{\n                    maxgt[i][j]=min(minlt[i-1][j],minlt[i][j-1])*grid[i][j];\n                    minlt[i][j]=max(maxgt[i-1][j],maxgt[i][j-1])*grid[i][j];\n                }\n            }\n        }\n        if(maxgt[m-1][n-1]<0) return -1;\n        else{\n            return maxgt[m-1][n-1]%mod;\n        }\n    }\n};\n```\n### 最大得分的路径数目\n```C\nusing PII = pair<int, int>;\n\nclass Solution {\nprivate:\n    static constexpr int mod = (int)1e9 + 7;\n\npublic:\n    void update(vector<vector<PII>>& dp, int n, int x, int y, int u, int v) {\n        if (u >= n || v >= n || dp[u][v].first == -1) {\n            return;\n        }\n        if (dp[u][v].first > dp[x][y].first) {\n            dp[x][y] = dp[u][v];\n        }\n        else if (dp[u][v].first == dp[x][y].first) {\n            dp[x][y].second += dp[u][v].second;\n            if (dp[x][y].second >= mod) {\n                dp[x][y].second -= mod;\n            }\n        }\n    }\n\n    vector<int> pathsWithMaxScore(vector<string>& board) {\n        int n = board.size();\n        vector<vector<PII>> dp(n, vector<PII>(n, {-1, 0}));\n        dp[n - 1][n - 1] = {0, 1};\n        for (int i = n - 1; i >= 0; i--) {\n            for (int j = n - 1; j >= 0; j--) {\n                if (!(i == n - 1 && j == n - 1) && board[i][j] != 'X') {\n                    update(dp, n, i, j, i + 1, j);\n                    update(dp, n, i, j, i, j + 1);\n                    update(dp, n, i, j, i + 1, j + 1);\n                    if (dp[i][j].first != -1) {\n                        dp[i][j].first += (board[i][j] == 'E' ? 0 : board[i][j] - '0');\n                    }\n                }\n            }\n        }\n        return dp[0][0].first == -1 ? vector<int>{0, 0} : vector<int>{dp[0][0].first, dp[0][0].second};\n    }\n};\n```\n### 矩阵中和能被 K 整除的路径\n```C\n/*把路径和模 k 的结果当成一个扩展维度*/\nclass Solution {\npublic:\n    int numberOfPaths(vector<vector<int>> &grid, int k) {\n        const int mod = 1e9 + 7;\n        int m = grid.size(), n = grid[0].size(), f[m + 1][n + 1][k];\n        memset(f, 0, sizeof(f)); // f[i][j][v] 表示从左上走到 (i,j)，且路径和模 k 的结果为 v 时的路径数\n        f[0][1][0] = 1;\n        for (int i = 0; i < m; ++i)\n            for (int j = 0; j < n; ++j)\n                for (int v = 0; v < k; ++v)\n                    f[i + 1][j + 1][(v + grid[i][j]) % k] = (f[i + 1][j][v] + f[i][j + 1][v]) % mod;\n        return f[m][n][0];\n    }\n};\n/*代码实现时，为了避免判断是否越界，可以把下标都加一。此时可以设初始值 f[0][1][0]=1（或者 f[1][0][0]=1）简化一点点代码。*/\n```\n### 地下城游戏\n```C\n\n```\n# 背包\n## 0-1 背包\n>*每个物品只能选一次*\n### 和为目标值的最长子序列的长度\n```C\n\n```\n## 完全背包\n## 多重背包\n## 分组背包\n# 经典线性 DP\n## 最长公共子序列（LCS）\n>*一般定义f[i][j]表示对(s[:i],t[:j])的求解结果。*\n### 最长公共子序列\n```C++\nclass Solution {\npublic:\n    int longestCommonSubsequence(string text1, string text2) {\n        int m=text1.size(),n=text2.size();\n        vector<vector<int>> dp(m+1,vector<int>(n+1)); \n        for(int i=1;i<=m;i++){\n            char c1=text1[i-1];\n            for(int j=1;j<=n;j++){\n                char c2=text2[j-1];\n                if(c1==c2){\n                    dp[i][j]=dp[i-1][j-1]+1;\n                }\n                else{\n                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);\n                }\n            }\n        }\n        return dp[m][n];\n    }\n};\n```\n### 两个字符串的删除操作\n```C++\nclass Solution {\npublic:\n    int minDistance(string word1, string word2) {\n        int m = word1.size();\n        int n = word2.size();\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1));\n\n        for (int i = 1; i <= m; i++) {\n            char c1 = word1[i - 1];\n            for (int j = 1; j <= n; j++) {\n                char c2 = word2[j - 1];\n                if (c1 == c2) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                } else {\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n\n        int lcs = dp[m][n];\n        return m - lcs + n - lcs;\n    }\n};\n```\n### 两个字符串的最小ASCII删除和\n```C++\nclass Solution {\npublic:\n    int minimumDeleteSum(string s1, string s2) {\n        int m = s1.size();\n        int n = s2.size();\n        vector<vector<int>> dp(m + 1, vector<int>(n + 1));\n\n        for (int i = 1; i <= m; ++i) {\n            dp[i][0] = dp[i - 1][0] + s1[i - 1];\n        }\n        for (int j = 1; j <= n; ++j) {\n            dp[0][j] = dp[0][j - 1] + s2[j - 1];\n        }\n        for (int i = 1; i <= m; i++) {\n            char c1 = s1[i - 1];\n            for (int j = 1; j <= n; j++) {\n                char c2 = s2[j - 1];\n                if (c1 == c2) {\n                    dp[i][j] = dp[i - 1][j - 1];\n                } else {\n                    dp[i][j] = min(dp[i - 1][j] + s1[i - 1], dp[i][j - 1] + s2[j - 1]);\n                }\n            }\n        }\n\n        return dp[m][n];\n    }\n};\n```\n### 编辑距离\n```C++\n\n```\n## 最长递增子序列（LIS）\n","tags":["编程","动态规划"]},{"title":"软件工程综合实践","url":"/2024/10/01/软件工程综合实践/","content":"## 故事场景\n>你们是几名到某软件开发公司（以下简称T软）实习的学生。上班第一天，老板告诉你们，公司现在有个紧急项目，要求三周后上线，但是……上周末，这个项目唯一的程序员，小东，因不满公司的薪水待遇过低而离职了，现在留下了一个半成品的烂摊子，重担落在了你们几个毫无开发经验的实习生身上……\n## JDBC 项目\n**主要目标：解决“使用 JDBC 封装数据层，并实现增删改查”的问题。**\n## 前端项目\n**主要目标：解决“使用 HTML5+CSS3+JavaScript 开发企业级前端静态页面”的问题。**\n## JavaWeb 项目\n**主要目标：解决“使用 Vue（前端）+Servlet（服务端）开发基于前后端分离架构应用程序”的问题。**\n## SpringBoot 项目\n**主要目标：解决“使用 Vue（前端）+SpringBoot（服务端）开发基于前后端分离架构应用程序”的问题。**\n## SpringCloud 项目\n**主要目标：解决“使用 Vue（前端）+SpringCloud（服务端）开发基于微服务的互联网应用程序”的问题。**","tags":["开发"]},{"title":"计算机网络实践记录","url":"/2024/09/28/计算机网络实践记录/","content":"---\n- 天津大学 2024 计算机网络 TCP 课程实践\n- Lab Member：海棠未雨，梨花先雪\n- 最终成绩 +∞ 分捏 😋\n---\n# 文件结构说明\n```markdown\ntju_tcp ----------------- 项目根目录 \n├─ build ---------------- 存放所有编译的中间文件\n│  ├─ kernel.o\n│  ├─ tju_packet.o  \n│  └─ tju_tcp.o\n├─ inc ------------------ 存放所有头文件\n│  ├─ global.h ---------- 定义一些全局都会用到的变量和结构\n│  ├─ kernel.h ---------- 模拟一部分linux内核行为 比如如何发送数据到下一层 根据五元组查找socket等\n│  ├─ tju_packet.h ------ 定义TCP所用到的数据包格式 提供各种数据包的操作(创建 获得字段等)\n│  └─ tju_tcp.h --------- 需要实现的TCP的各种结构和功能的定义\n├─ src ------------------ 存放所有源代码文件\n│  ├─ client.c ---------- 客户端主函数实现\n│  ├─ server.c ---------- 服务端主函数实现\n│  ├─ kernel.c ---------- 虚拟内核实现\n│  ├─ tju_packet.c ------ 可靠层包封装实现\n│  └─ tju_tcp.c --------- 可靠层实现\n├─ Makefile ------------- 生成脚本\n├─ README.md ------------ 文件说明\n└─ bin\n   ├─ client\n   └─ server\n```\n---\n# 系统环境信息\n```SHELL\nneofetch\n--------------\nOS: Ubuntu 20.04.2 LTS x86_64\nHost: Oracle Corporation VirtualBox\nKernel: 5.4.0-80-generic\nUptime: 3 mins\nPackages: 676 (dpkg), 4 (snap)\nShell: bash 5.0.17\nResolution: 800x600\nTerminal: /dev/pts/0\nCPU: 11th Gen Intel i7-11800H (2) @ 2.304GHz\nGPU: VirtualBox Graphics Adapter\nMemory: 294MiB / 981MiB\n```\n---\n# 具体实验记录\n## 连接管理\n<center>\n<img src=\"https://s2.loli.net/2024/10/11/t2LOxSBZgRkiblj.png\" width=\"60%\" />\n</center>\n\n### 三次握手建立连接\n**1. tju_connect( )**\n`tju_connect( )`函数是三次握手的开端。在该函数中，客户端的sock绑定好本地的ip和port后向服务器端发送SYN包，同时把当前的状态变化为SYN_SENT。成功建立连接后将sock放入ESTABLISHED的hash表中。\n```C\nint tju_connect(tju_tcp_t* sock, tju_sock_addr target_addr){\n    sock->established_remote_addr = target_addr;\n\n    tju_sock_addr local_addr;\n    local_addr.ip = inet_network(CLIENT_IP);\n    local_addr.port = 5678; // 连接方进行connect连接的时候 内核中是随机分配一个可用的端口\n    sock->established_local_addr = local_addr;\n\n    // 这里也不能直接建立连接 需要经过三次握手\n    // 实际在linux中 connect调用后 会进入一个while循环\n    // 循环跳出的条件是socket的状态变为ESTABLISHED 表面看上去就是 正在连接中 阻塞\n    // 而状态的改变在别的地方进行 在我们这就是tju_handle_packet\n    uint32_t seq = 0;  // 序列号\n    uint32_t ack = 0;  // 确认号\n    uint8_t flag=SYN_FLAG_MASK; //flag标记为：连接状态进行到哪一步\n    char *SYN = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port,seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, 1, 0, NULL, 0);\n    sendToLayer3(SYN, DEFAULT_HEADER_LEN); //客户端向服务器端发送同步报文--第一次握手\n    change_sock_state(sock, SYN_SENT);\n    // printf(\"client发送SYN\\n\");\n    \n    Timeout_retransmission(sock, ESTABLISHED, SYN, DEFAULT_HEADER_LEN); //阻塞等待，直到sock被建立\n    int hashval = cal_hash(sock->established_local_addr.ip, sock->established_local_addr.port,sock->established_remote_addr.ip, sock->established_remote_addr.port);\n    established_socks[hashval] = sock;\n    return 0;\n}\n```\n**2. Timeout_retransmission( )**\n```C\nvoid Timeout_retransmission(tju_tcp_t* sock, int exp_state, char* pkt, int pktlen) { //超时重传发包函数\n    //printf(\"bg1\\n\");\n    long timeout = 100000L;\n    struct timeval start_time, end_time;\n    gettimeofday(&start_time, NULL);\n    while (sock->state != exp_state){\n        gettimeofday(&end_time, NULL);\n        long Time = 1000000L * (end_time.tv_sec - start_time.tv_sec) + (end_time.tv_usec - start_time.tv_usec);\n        if (Time >= timeout) { //超时重传\n            gettimeofday(&start_time, NULL);\n            sendToLayer3(pkt, pktlen);\n        }\n    }\n    //printf(\"ed1\\n\");\n}\n```\n**3. change_sock_state( )**\n```C\nvoid change_sock_state(tju_tcp_t* sock, int state) {  //添加：sock状态改变\n    while (pthread_mutex_lock(&(sock->state_lock)) != 0) ; //改变sock状态前先加锁\n    sock->state = state;  \n    pthread_mutex_unlock(&(sock->state_lock)); //解锁\n}\n```\n**4. tju_accept()**\n`tju_accept( )`函数中添加了一个阻塞，使得只有当全连接hash表中存在这一个sock，服务器端才算连接完成，才能把新的sock加入到ESTABLISHED的hash表中。\n```C\ntju_tcp_t *tju_accept(tju_tcp_t *listen_sock){\n    while (listen_sock->received_len < DEFAULT_HEADER_LEN);\n    char *header = malloc(DEFAULT_HEADER_LEN);\n    memcpy(header, listen_sock->received_buf, DEFAULT_HEADER_LEN);\n    memset(listen_sock->received_buf, 0, DEFAULT_HEADER_LEN);\n    listen_sock->received_buf = NULL;\n    listen_sock->received_len = listen_sock->received_len - DEFAULT_HEADER_LEN;\n\n    tju_tcp_t* new_conn = (tju_tcp_t*)malloc(sizeof(tju_tcp_t));\n    pthread_mutex_init(&(new_conn->state_lock), NULL);\n    memcpy(new_conn, listen_sock, sizeof(tju_tcp_t));\n\n    tju_sock_addr local_addr, remote_addr;\n    /*\n     这里涉及到TCP连接的建立\n     正常来说应该是收到客户端发来的SYN报文\n     从中拿到对端的IP和PORT\n     换句话说 下面的处理流程其实不应该放在这里 应该在tju_handle_packet中\n    */\n    remote_addr.ip = inet_network(CLIENT_IP);  //具体的IP地址\n    remote_addr.port = 5678;  //端口\n\n    local_addr.ip = listen_sock->bind_addr.ip;  //具体的IP地址\n    local_addr.port = listen_sock->bind_addr.port;  //端口\n\n    new_conn->established_local_addr = local_addr;\n    new_conn->established_remote_addr = remote_addr;\n\n    while (listen_sock->state != ESTABLISHED) ;\n    change_sock_state(new_conn, ESTABLISHED);\n\n    // 将新的conn放到内核建立连接的socket哈希表中\n    int hashval = cal_hash(local_addr.ip, local_addr.port, remote_addr.ip, remote_addr.port);\n    established_socks[hashval] = new_conn;\n    return new_conn;\n}\n```\n**5. tju_handle_packet( )**\n`tju_handle_packet( )`函数中需要解决对各种报文的解析。`onTCPPocket( )`函数如果从established_hash或listen_hash中找到了对应的socket，就会调用 `tju_handle_packet( )`函数对收到的数据包进行处理。\n```C\nint tju_handle_packet(tju_tcp_t* sock, char* pkt){\n    if (sock->state == LISTEN && get_flags(pkt) == SYN_FLAG_MASK){ //第二次握手\n        while (pthread_mutex_lock(&(sock->recv_lock)) != 0);\n        if (sock->received_buf == NULL) sock->received_buf = malloc(DEFAULT_HEADER_LEN);\n        else sock->received_buf = realloc(sock->received_buf, sock->received_len + DEFAULT_HEADER_LEN);\n        memcpy(sock->received_buf + sock->received_len, pkt, DEFAULT_HEADER_LEN);\n        sock->received_len += DEFAULT_HEADER_LEN;\n        pthread_mutex_unlock(&(sock->recv_lock));\n\n        tju_sock_addr remote;\n        remote.ip = inet_network(CLIENT_IP);\n        remote.port = get_src(pkt);\n\n        sock->established_local_addr = sock->bind_addr;\n        sock->established_remote_addr = remote;\n\n        int hashval = cal_hash(sock->established_local_addr.ip, sock->established_local_addr.port, remote.ip, remote.port);\n        half_connection[hashval] = sock;  //收到SYN报文后放进LISTEN的半连接队列中\n        established_socks[hashval] = sock; //还会将该新建的socket放到ehash中\n\n        uint32_t seq = 0;  \n        uint32_t ack = get_seq(pkt) + 1; //确认号是SYN报文序列号+1\n        uint8_t flag = SYN_FLAG_MASK | ACK_FLAG_MASK; //状态记为SYN+ACK，这里采用位运算|\n        char *SYNACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, 1, 0, NULL, 0);\n        sendToLayer3(SYNACK, DEFAULT_HEADER_LEN);\n        change_sock_state(sock, SYN_RECV);\n    }\n    else if (sock->state == SYN_SENT && get_flags(pkt) == (ACK_FLAG_MASK | SYN_FLAG_MASK)){ //第三次握手\n        //printf(\"client收到SYCACK, 准备发送ACK\\n\");\n        uint32_t seq = get_ack(pkt);\n        uint32_t ack = get_seq(pkt) + 1;\n        uint8_t flag = ACK_FLAG_MASK;\n        sock->window.wnd_send->base = seq;\n        sock->window.wnd_send->nextseq = seq;\n        char *ACK = create_packet_buf(sock->established_local_addr.port, get_src(pkt), seq,ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, 1, 0, NULL, 0);\n        sendToLayer3(ACK, DEFAULT_HEADER_LEN);\n        change_sock_state(sock, ESTABLISHED);\n    }\n    else if (sock->state == SYN_SENT && get_flags(pkt) == SYN_FLAG_MASK){ //第三次握手（奇怪）\n        // //printf(\"client收到SYCACK, 准备发送ACK\\n\");\n        uint32_t seq = get_ack(pkt);\n        uint32_t ack = get_seq(pkt) + 1;\n        uint8_t flag = ACK_FLAG_MASK;\n        sock->window.wnd_send->base = seq;\n        sock->window.wnd_send->nextseq = seq;\n        char *ACK = create_packet_buf(sock->established_local_addr.port, get_src(pkt), seq,ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, 0, 0, NULL, 0);\n        sendToLayer3(ACK, DEFAULT_HEADER_LEN);\n        change_sock_state(sock, ESTABLISHED);\n    }\n    else if(sock->state == ESTABLISHED && get_flags(pkt) == (SYN_FLAG_MASK | ACK_FLAG_MASK)){  //三次握手第三个包的重传\n        uint32_t seq = get_ack(pkt);\n        uint32_t ack = get_seq(pkt) + 1;\n        uint8_t flag = ACK_FLAG_MASK;\n        char *ACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, 1, 0, NULL, 0);\n        sendToLayer3(ACK, DEFAULT_HEADER_LEN);\n    }\n    else if (sock->state == SYN_RECV && get_flags(pkt) == ACK_FLAG_MASK){\n        // //printf(\"server收到ACK\\n\");\n        sock->window.wnd_recv->expect_seq = get_seq(pkt) + get_plen(pkt) - DEFAULT_HEADER_LEN;\n        int hash = cal_hash(sock->established_local_addr.ip, sock->established_local_addr.port,sock->established_remote_addr.ip, sock->established_remote_addr.port);\n        com_connection[hash] = sock;\n        half_connection[hash] = NULL;\n        change_sock_state(sock, ESTABLISHED);\n        if (get_plen(pkt) > DEFAULT_HEADER_LEN) { //ACK包携带信息\n            pkt2buffer(sock, pkt);\n        }\n    }\n```\n**6. pkt2buffer( )**\n```C\nvoid pkt2buffer(tju_tcp_t* sock, char* pkt) {\n    //printf(\"bg6\\n\");\n    uint32_t data_len = get_plen(pkt) - DEFAULT_HEADER_LEN;\n\n    while (pthread_mutex_lock(&(sock->recv_lock)) != 0); // 加锁\n    if (sock->received_buf == NULL){\n        sock->received_buf = malloc(data_len);\n    }\n    else{\n        sock->received_buf = realloc(sock->received_buf, sock->received_len + data_len);\n    }\n    memcpy(sock->received_buf + sock->received_len, pkt + DEFAULT_HEADER_LEN, data_len);    \n    sock->received_len += data_len;\n    pthread_mutex_unlock(&(sock->recv_lock)); // 解锁\n    //printf(\"ed6\\n\");\n}\n```\n### 四次挥手关闭连接\n**1. tju_close ( )**\n四次挥手有两种情况，分别为先后关闭和同时关闭，两种方式首先都需要调用`tju_close( )`函数，因此，在`tju_close( )`函数中，需要构造一个 FIN+ACK 报文，seq和ack都是当前报文窗口的下一个数值，并把自身状态变为 FIN-WAIT1。\n```C\nint tju_close (tju_tcp_t* sock){\n    uint16_t flag = FIN_FLAG_MASK | ACK_FLAG_MASK;\n    uint32_t seq = sock->window.wnd_send->nextseq;\n    uint32_t ack = sock->window.wnd_send->nextseq;\n    char* FINACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port,seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, 0, 0, NULL, 0);\n    sendToLayer3(FINACK, DEFAULT_HEADER_LEN);\n    change_sock_state(sock, FIN_WAIT_1);\n    sock->window.wnd_send->nextseq++;\n\n    while (sock->state != CLOSED) ;\n    //printf(\"连接完全关闭\\n\");\n    return 0;\n}\n```\n**2. tju_handle_packet( )**\n接下来分为两种情况，但处理过程均在`tju_handle_packet( )`中完成，`tju_handle_packet( )`作为对收到的包进行响应的函数。\n```C\nint tju_handle_packet(tju_tcp_t* sock, char* pkt){\n    ``````\n    ``````\n    ``````\n    else if (sock->state == ESTABLISHED && get_flags(pkt) == (FIN_FLAG_MASK | ACK_FLAG_MASK)){ // server收到第一次挥手，并进行第二次挥手和第三次挥手\n        uint32_t seq = get_ack(pkt);\n        uint32_t ack = get_seq(pkt) + 1;\n        uint16_t flag = ACK_FLAG_MASK;\n        char *ACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, 0, 0, NULL, 0);\n        sendToLayer3(ACK, DEFAULT_HEADER_LEN);\n        //printf(\"发送第二次挥手报文\\n\");\n        change_sock_state(sock, CLOSE_WAIT);\n        \n        sleep(1);\n\n        flag = ACK_FLAG_MASK | FIN_FLAG_MASK;\n        seq = sock->window.wnd_send->nextseq;\n        ack = get_seq(pkt) + 1;\n        char *FINACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, 0, 0, NULL, 0);\n        sendToLayer3(FINACK, DEFAULT_HEADER_LEN);\n        //printf(\"发送第三次挥手报文\\n\");\n        change_sock_state(sock, LAST_ACK);\n        Timeout_retransmission(sock, CLOSED, FINACK, DEFAULT_HEADER_LEN);\n    } \n    else if (sock->state == ESTABLISHED && get_flags(pkt) == FIN_FLAG_MASK){ // server收到第一次挥手，并进行第二次挥手和第三次挥手\n        uint32_t seq = get_ack(pkt);\n        uint32_t ack = get_seq(pkt) + 1;\n        uint16_t flag = ACK_FLAG_MASK;\n        char *ACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, 0, 0, NULL, 0);\n        sendToLayer3(ACK, DEFAULT_HEADER_LEN);\n        change_sock_state(sock, CLOSE_WAIT);\n        //printf(\"发送第二次挥手报文\\n\");\n\n        sleep(1);\n\n        flag = ACK_FLAG_MASK | FIN_FLAG_MASK;\n        char *FINACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, 0, 0, NULL, 0);\n        sendToLayer3(FINACK, DEFAULT_HEADER_LEN);\n        //printf(\"发送第三次挥手报文\\n\");\n        change_sock_state(sock, LAST_ACK);\n        Timeout_retransmission(sock, CLOSED, FINACK, DEFAULT_HEADER_LEN);\n    } \n    else if (sock->state == FIN_WAIT_1 && get_flags(pkt) == ACK_FLAG_MASK){ // client收到第二次挥手\n        change_sock_state(sock, FIN_WAIT_2);\n        //printf(\"收到第二次挥手报文\\n\");\n    } \n    else if (sock->state == FIN_WAIT_2 && (get_flags(pkt) == (ACK_FLAG_MASK | FIN_FLAG_MASK))){ // client收到第三次挥手进行第四次挥手并关闭连接\n        uint32_t seq = get_ack(pkt);\n        uint32_t ack = get_seq(pkt) + 1;\n        uint32_t flag = ACK_FLAG_MASK;\n        char *ACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN,flag, 0, 0, NULL, 0);\n        sendToLayer3(ACK, DEFAULT_HEADER_LEN);\n        //printf(\"收到第三次挥手报文, 并发出第四次挥手\\n\");\n        change_sock_state(sock, TIME_WAIT);\n        int hash = cal_hash(sock->established_local_addr.ip, sock->established_local_addr.port,    sock->established_remote_addr.ip, sock->established_remote_addr.port);\n        //这里要等待2MSL\n        change_sock_state(sock, CLOSED);\n        established_socks[hash] = NULL;\n        //printf(\"关闭连接\\n\");\n    } \n    else if (sock->state == LAST_ACK && (get_flags(pkt) == ACK_FLAG_MASK)){ // server收到第四次挥手并关闭连接\n        int hash = cal_hash(sock->established_local_addr.ip, sock->established_local_addr.port, sock->established_remote_addr.ip, sock->established_remote_addr.port);\n        established_socks[hash] = NULL;\n        half_connection[hash] = NULL;\n        com_connection[hash] = NULL;\n        change_sock_state(sock, CLOSED);\n        //printf(\"关闭连接\\n\");\n    }\n    else if (sock->state == FIN_WAIT_1 && (get_flags(pkt) == (FIN_FLAG_MASK | ACK_FLAG_MASK))){ // 同时关闭收到第一次挥手\n        change_sock_state(sock, CLOSING);\n        uint32_t seq = get_ack(pkt) + 1;\n        uint32_t ack = get_seq(pkt) + 1;\n        uint16_t flag = ACK_FLAG_MASK;\n        char* ACK = create_packet_buf(sock->established_local_addr.port,sock->established_remote_addr.port,seq,ack,DEFAULT_HEADER_LEN,DEFAULT_HEADER_LEN,flag,0,0,NULL,0);\n        sendToLayer3(ACK,DEFAULT_HEADER_LEN);\n        Timeout_retransmission(sock, CLOSED, ACK, DEFAULT_HEADER_LEN);\n        // //printf(\"同时关闭发出ACK\\n\");\n    } \n    else if(sock->state == FIN_WAIT_1 && get_flags(pkt) == FIN_FLAG_MASK){ // 同时关闭收到第一次挥手\n        change_sock_state(sock, CLOSING);\n        uint32_t seq = get_ack(pkt) + 1;\n        uint32_t ack = get_seq(pkt) + 1;\n        uint16_t flag = ACK_FLAG_MASK;\n        char* ACK = create_packet_buf(sock->established_local_addr.port,sock->established_remote_addr.port,seq,ack,DEFAULT_HEADER_LEN,DEFAULT_HEADER_LEN,flag,0,0,NULL,0);\n        sendToLayer3(ACK, DEFAULT_HEADER_LEN);\n        Timeout_retransmission(sock, CLOSED, ACK, DEFAULT_HEADER_LEN);\n    }\n    else if (sock->state == CLOSING && get_flags(pkt) == ACK_FLAG_MASK){ // 同时关闭时收到第三次挥手\n        change_sock_state(sock, TIME_WAIT);\n        //等待2MSL\n        int hash = cal_hash(sock->established_local_addr.ip, sock->established_local_addr.port, sock->established_remote_addr.ip, sock->established_remote_addr.port);\n        established_socks[hash] = NULL;\n        half_connection[hash] = NULL;\n        com_connection[hash] = NULL;\n        change_sock_state(sock, CLOSED);\n        //printf(\"同时关闭彻底关闭\\n\");\n    }\n}\n```\n## 可靠数据传输\n### 发送缓冲区管理\n**1. `global.h` 中宏定义 TCP 发送窗口大小。**\n```C\n#define TCP_SENDWN_SIZE 1000 \n```\n**2. `tju_packet.h` 中为发送缓冲区创建1000个报文长度的循环队列，方便数据包超时重传。**\n```C\n// TCP 报文的结构定义\ntypedef struct {\n\ttju_header_t header;\n\tstruct timeval sent_time;\n\tchar* data;\n} tju_packet_t;\ntju_packet_t* pktlist[TCP_SENDWN_SIZE];\n```\n**3. tju_send( )**\n上层调用 `tju_send( )` 时，我们在 `tju_send( )`函数内创建发送线程并把发送数据存入缓冲区中。\n&emsp;这里我们先了解一下创建线程 `pthread_create( )`函数。\n>int pthread_create(pthread_t* restrict tidp,const pthread_attr_t* restrict_attr,void* (*start_rtn)(void*),void *restrict arg);\n>- tidp：事先创建好的pthread_t类型的参数。成功时tidp指向的内存单元被设置为新创建线程的线程ID。\n>- attr：用于定制各种不同的线程属性。APUE的12.3节讨论了线程属性。通常直接设为NULL。\n>- start_rtn：新创建线程从此函数开始运行。无参数是arg设为NULL即可。\n>- arg：start_rtn函数的参数。无参数时设为NULL即可。有参数时输入参数的地址。当多于一个参数时应当使用结构体传入。\n>- 返回值为 0（表示线程成功创建）。\n```C\nint send_thread_flag = 0;\n\nint tju_send(tju_tcp_t* sock, const void *buffer, int len){\n    // 这里当然不能直接简单地调用sendToLayer\n    if(!send_thread_flag){\n        send_thread_flag = 1;\n        pthread_t sendthreadid;\n        int ret = pthread_create(&sendthreadid, NULL, send_pkt, (void *)sock);\n    }\n\n    while (pthread_mutex_lock(&(sock->send_lock)) != 0) ;\n    memcpy(sock->sending_buf + sock->index, (char*)buffer, len);\n    sock->sending_len += len;\n    sock->index += len;\n    pthread_mutex_unlock(&(sock->send_lock));\n\n    return 0;\n}\n```\n**4. send_pkt( )**\n```C\nvoid *send_pkt(tju_tcp_t* sock){\n    //printf(\"bg4\\n\");\n    //struct timeval start_time, now_time;\n    //gettimeofday(&start_time, NULL);\n    //long deltatime = 0; //时间差\n    while (1){ //不断检查和发送数据包\n        if (sock->window.wnd_send->nextseq < sock->index){ //检查发送窗口：检查当前发送序列号是否小于索引，确保有数据需要发送。\n            //gettimeofday(&now_time, NULL);\n            //deltatime = now_time.tv_sec - start_time.tv_sec;\n\n            while (pthread_mutex_lock(&(sock->send_lock)) != 0);\n            int unlen = sock->sending_len - (sock->window.wnd_send->nextseq - sock->window.wnd_send->base); //计算当前未发送的数据长度。 \n            int len = min(unlen, MAX_DLEN); //确定本次发送的长度，取未发送长度和最大数据长度中的最小值。 \n            pthread_mutex_unlock(&(sock->send_lock));\n            int leftlen = sock->window.wnd_send->rwnd - (sock->window.wnd_send->nextseq - sock->window.wnd_send->base);\n            len =len>leftlen?leftlen:len;            \n\n            if (sock->window.wnd_send->nextseq - sock->window.wnd_send->base + len <= sock->window.wnd_send->rwnd) { //检查窗口大小：检查当前已发送的长度加上本次发送长度是否在接收窗口范围内。 \n                uint32_t seq = sock->window.wnd_send->nextseq;\n                uint32_t ack = seq + len; //不理解 \n                uint8_t flag = ACK_FLAG_MASK;\n                uint16_t pkt_len = len + DEFAULT_HEADER_LEN;\n                char *data = (char *)malloc(MAX_DLEN);\n                memcpy(data, sock->sending_buf + sock->window.wnd_send->nextseq, len);\n                tju_packet_t *datapacket = create_packet(sock->established_local_addr.port, sock->established_remote_addr.port,seq, ack, DEFAULT_HEADER_LEN, pkt_len, flag, 0, 0, data, len);\n                char *ACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port,seq, ack, DEFAULT_HEADER_LEN, pkt_len, flag, 0, 0, data, len);\n\n                sendToLayer3(ACK, pkt_len);\n                \n                sock->window.wnd_send->nextseq += len;\n                pktlist[sock->packetr] = datapacket;\n                gettimeofday(&pktlist[sock->packetr]->sent_time, NULL);\n                sock->packetr = (sock->packetr + 1) % TCP_SENDWN_SIZE;\n                if (len == (int)(sock->window.wnd_send->nextseq - sock->window.wnd_send->base)){\n                    gettimeofday(&(sock->window.wnd_send->send_time), NULL);\n                    \n                    while(pthread_mutex_lock(&(sock->window.wnd_send->ack_cnt_lock)) != 0);\n                    sock->window.wnd_send->ack_cnt = 0;\n                    pthread_mutex_unlock(&(sock->window.wnd_send->ack_cnt_lock));\n                }\n            }\n        }\n    }\n    printf(\"ed4\\n\");\n}\n```\n### 失序报文数组的管理\n**1. tju_handle_packet( )**\n`tju_handle_packet( )`中添加建立连接后收到数据包的处理。\n```C\nint tju_handle_packet(tju_tcp_t* sock, char* pkt){\n    `````` 建立连接 ``````\n    ````````````````````\n    ````````````````````\n    else if(sock->state == ESTABLISHED && get_flags(pkt) == ACK_FLAG_MASK){ //收到数据包\n        char hostname[8];\n        gethostname(hostname, 8);\n        if (strcmp(hostname, \"server\") == 0){\n            serverrdt(sock, pkt);\n        } \n        else{\n            clientrdt(sock, pkt);\n        } \n    }\n    `````` 关闭连接 ``````\n    ````````````````````\n    ````````````````````\n}\n```\n**2. `tju_tcp_t` 结构体中创建空间用来存储失序报文并记录失序报文的个数。**\n```C\n// TJU_TCP 结构体 保存TJU_TCP用到的各种数据\ntypedef struct {\n\tchar unorder[100][MAX_LEN]; //失序报文数组\n\tint unolen; //失序报文个数\n} tju_tcp_t;\n```\n**3. serverrdt( )**\n```C\nvoid serverrdt(tju_tcp_t* sock, char* pkt){ // 服务器端处理数据包\n    if (get_seq(pkt) < (sock->window.wnd_recv->expect_seq)){ //函数发送一个 ACK 响应已确认接收\n        uint32_t seq = sock->window.wnd_send->nextseq;\n        uint32_t ack = sock->window.wnd_recv->expect_seq;\n        uint8_t flag = ACK_FLAG_MASK;\n        char *ACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, TCP_RECVWN_SIZE-(sock->unolen)*MAX_DLEN, 0, NULL, 0);\n        sendToLayer3(ACK, DEFAULT_HEADER_LEN);\n    }\n    else if(get_seq(pkt) > (sock->window.wnd_recv->expect_seq)){ //数据包乱序，函数将包暂存，并发送 ACK，同时更新接收窗口\n        uint32_t seq = sock->window.wnd_send->nextseq;\n        uint32_t ack = sock->window.wnd_recv->expect_seq;\n        uint8_t flag = ACK_FLAG_MASK;\n        char *ACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, TCP_RECVWN_SIZE-(sock->unolen)*MAX_DLEN, 0, NULL, 0);\n        sendToLayer3(ACK, DEFAULT_HEADER_LEN);\n\n        if((sock->unolen) > MAX_PKT_IN_WINDOW)  return;\n        memcpy(sock->unorder[sock->unolen], pkt, get_plen(pkt));\n        sock->unolen++;\n    }\n    else{ //刚刚好\n        sock->window.wnd_send->nextseq=get_ack(pkt);\n        sock->window.wnd_recv->expect_seq+=get_plen(pkt)-DEFAULT_HEADER_LEN;\n        pkt2buffer(sock,pkt);\n        if(sock->unolen == 0){\n            uint32_t seq = sock->window.wnd_send->nextseq;\n            uint32_t ack = sock->window.wnd_recv->expect_seq;\n            uint8_t flag = ACK_FLAG_MASK;\n            char *ACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag,TCP_RECVWN_SIZE-(sock->unolen)*MAX_DLEN, 0, NULL, 0);\n            sendToLayer3(ACK, DEFAULT_HEADER_LEN);\n        }\n        else{\n            int len = sock->unolen;\n\n            for(int i = 0; i < len; i++){\n                for(int j = i + 1; j < len; j++){\n                    if(get_seq(sock->unorder[i])>get_seq(sock->unorder[j])){\n                        my_swap(&sock->unorder[i], &sock->unorder[j]);\n                    }\n                }\n            }\n            int index = 0;\n            for(; index < len; index++){\n                if(get_seq(sock->unorder[index]) == sock->window.wnd_recv->expect_seq){\n                    sock->window.wnd_send->nextseq = get_ack(sock->unorder[index]);\n                    sock->window.wnd_recv->expect_seq += get_plen(sock->unorder[index]) - DEFAULT_HEADER_LEN;\n                    pkt2buffer(sock, sock->unorder[index]);\n                }\n                else if(get_seq(sock->unorder[index]) < (sock->window.wnd_recv->expect_seq)) continue;\n                else break;\n            }\n            for (int i = index; i < len; i++){\n                memcpy(sock->unorder[i - index], sock->unorder[i], sizeof(sock->unorder[i]));\n            }\n            sock->unolen -= index;\n           \n            uint32_t seq = sock->window.wnd_send->nextseq;\n            uint32_t ack = sock->window.wnd_recv->expect_seq;\n            uint8_t flag = ACK_FLAG_MASK;\n            char *ACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, TCP_RECVWN_SIZE-(sock->unolen)*MAX_DLEN, 0, NULL, 0);\n\n            sendToLayer3(ACK, DEFAULT_HEADER_LEN);\n        }\n    }\n}\n```\n**4. my_swap( )**\n```C\nvoid my_swap(char** a, char** b){\n    char* tem = (char*)malloc(MAX_LEN);\n    memcpy(tem, a, get_plen(b));\n    memcpy(a, b, get_plen(b));\n    memcpy(b, tem, get_plen(tem));\n    free(tem);\n}\n```\n### 实现累计应答\n<center>\n<img src=\"https://s2.loli.net/2024/10/11/vKkuC1ibGfmo2sM.png\" width=\"60%\" />\n\nFigure 1. 累计应答\n</center>\n\n**1. clientrdt( )**\n`clientrdt( )`函数中添加累计应答处理。当发送方收到任意大于当前base的ack报文后，直接把当前base进行更新即可。\n```C\nvoid clientrdt(tju_tcp_t* sock, char* pkt){ // 客户端处理数据包\n    if (sock->window.wnd_send->base == sock->window.wnd_send->nextseq) return;\n    if (get_ack(pkt) < sock->window.wnd_send->base) return;\n    ``````\n    ``````\n    ``````\n    if(get_ack(pkt) > sock->window.wnd_send->base){\n        ``````\n        ``````\n        ``````\n        while(pthread_mutex_lock(&(sock->send_lock)) != 0); //加锁\n        while(sock->window.wnd_send->base < get_ack(pkt) && sock->window.wnd_send->base < sock->window.wnd_send->nextseq ){   \n            int pkt_len = pktlist[sock->packetl]->header.plen;\n            int datalen = pkt_len - DEFAULT_HEADER_LEN;\n            sock->sending_len -= datalen;\n            sock->window.wnd_send->base += datalen;\n            sock->packetl = (sock->packetl + 1) % TCP_SENDWN_SIZE;\n        }\n        pthread_mutex_unlock(&(sock->send_lock)); //解锁\n    }\n    ``````\n    ``````\n    ``````\n}\n```\n### 超时重传\n**1. tju_send( )**\n`tju_send( )` 中创建了一个新的线程判断是否要进行重传。\n```C\nint resend_thread_flag = 0;\n\nint tju_send(tju_tcp_t* sock, const void *buffer, int len){\n    ``````\n    ``````\n    ``````\n    if (!resend_thread_flag){\n        resend_thread_flag = 1;\n        pthread_t resendthreadid;\n        int ret = pthread_create(&resendthreadid, NULL,resend_pkt, (void *)sock);\n    }\n    ``````\n    ``````\n    ``````\n}\n```\n**2. resend_pkt( )**\n```C\nvoid *resend_pkt(tju_tcp_t* sock){\n    struct timeval start_time,now_time;\n    gettimeofday(&start_time, NULL);\n    long deltatime = 0;\n    while (1){\n        if (sock->window.wnd_send->base < sock->window.wnd_send->nextseq){\n            gettimeofday(&now_time, NULL);\n            deltatime = now_time.tv_sec - start_time.tv_sec;\n            if (deltatime > 100) break; //不理解\n            long nowtimeval = 1000000 * (now_time.tv_sec - sock->window.wnd_send->send_time.tv_sec) +  (now_time.tv_usec - sock->window.wnd_send->send_time.tv_usec);\n            long timeoutval = 1000000 * (sock->window.wnd_send->timeout.tv_sec) + (sock->window.wnd_send->timeout.tv_usec);\n            if (nowtimeval > timeoutval){ //超时重传\n                while(pktlist[sock->packetl] == NULL);\n                uint32_t seq = pktlist[sock->packetl]->header.seq_num;\n                uint32_t ack = pktlist[sock->packetl]->header.ack_num;\n                uint8_t flag = ACK_FLAG_MASK;\n                int pkt_len = pktlist[sock->packetl]->header.plen;\n                char *ACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack,DEFAULT_HEADER_LEN, pkt_len, flag, 0, 0, pktlist[sock->packetl]->data, pkt_len - DEFAULT_HEADER_LEN);\n                sendToLayer3(ACK, pkt_len);\n                gettimeofday(&pktlist[sock->packetl]->sent_time, NULL);\n                gettimeofday(&sock->window.wnd_send->send_time, NULL);\n            }\n        }\n    }\n}\n```\n**3. clientrdt( )**\n`clientrdt( )` 函数中添加动态设置超时间隔的实现。\n```C\nvoid clientrdt(tju_tcp_t* sock, char* pkt){ // 客户端处理数据包\n    ``````\n    ``````\n    ``````\n    if(get_ack(pkt) > sock->window.wnd_send->base){\n        //更新RTO\n        struct timeval nowtime;\n        gettimeofday(&nowtime, NULL);\n        long ntime = 1000000 * nowtime.tv_sec + nowtime.tv_usec;\n        long samplertt = 1000000 * (nowtime.tv_sec-pktlist[sock->packetl]->sent_time.tv_sec)+nowtime.tv_usec-pktlist[sock->packetl]->sent_time.tv_usec;\n        long estmatedrtt = sock->window.wnd_send->estmated_rtt;\n        long devrtt = sock->window.wnd_send->dev_rtt;\n        estmatedrtt = 1.0 * estmatedrtt * 7 / 8 + samplertt / 8;\n        devrtt = 1.0 * devrtt * 3 / 4 + (samplertt > 1.0 * estmatedrtt ? (samplertt - estmatedrtt) : (estmatedrtt - samplertt)) / 4;\n        sock->window.wnd_send->timeout.tv_usec = (estmatedrtt + 4 * devrtt) % 1000000;\n        sock->window.wnd_send->timeout.tv_sec = (estmatedrtt + 4 * devrtt) / 1000000;\n        sock->window.wnd_send->estmated_rtt = estmatedrtt;\n        sock->window.wnd_send->dev_rtt = devrtt;\n        double dsamplertt=(double)samplertt/(double)1000000;\n        double destmatedrtt=(double)estmatedrtt/(double)1000000;\n        double ddevrtt=(double)devrtt/(double)1000000;\n        double dtimegap=(double)(estmatedrtt + 4 * devrtt)/(double)1000000;\n        \n        while(pthread_mutex_lock(&(sock->window.wnd_send->ack_cnt_lock)) != 0);\n        sock->window.wnd_send->ack_cnt = 1;\n        pthread_mutex_unlock(&(sock->window.wnd_send->ack_cnt_lock));\n        ``````\n        ``````\n        ``````\n    }\n}\n```\n### 快速重传\n<center>\n<img src=\"https://s2.loli.net/2024/10/11/cj2PfZsz8abBVW9.png\" width=\"60%\" />\n\nFigure 1. 快速重传\n</center>\n\n**1. clientrdt( )**\n`clientrdt( )` 函数中添加快速重传的实现。\n```C\nvoid clientrdt(tju_tcp_t* sock, char* pkt){ // 客户端处理数据包\n    ``````\n    ``````\n    ``````\n    if(get_ack(pkt) == sock->window.wnd_send->base){ //冗余ACK\n        while(pthread_mutex_lock(&(sock->window.wnd_send->ack_cnt_lock)) != 0);\n        sock->window.wnd_send->ack_cnt++;\n        pthread_mutex_unlock(&(sock->window.wnd_send->ack_cnt_lock));\n\n        if(sock->window.wnd_send->ack_cnt == 3){ //快速重传 \n            ``````\n            uint32_t seq = pktlist[sock->packetl]->header.seq_num;\n            uint32_t ack = pktlist[sock->packetl]->header.ack_num;\n            uint8_t flag = ACK_FLAG_MASK;\n            int pkt_len = pktlist[sock->packetl]->header.plen;\n            char *ACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, pkt_len, ACK_FLAG_MASK, 0, 0, pktlist[sock->packetl]->data, pkt_len - DEFAULT_HEADER_LEN);\n            sendToLayer3(ACK, pkt_len);\n            sock->window.wnd_send->ack_cnt = 0;\n            gettimeofday(&pktlist[sock->packetl]->sent_time, NULL);            \n        }\n        return;\n    }\n    ``````\n    ``````\n    ``````\n}\n```\n## 流量控制\n### 接收方计算接受缓冲区大小\n**1. serverrdt( )**\n```C\nvoid serverrdt(tju_tcp_t* sock, char* pkt){// 服务端处理数据包\n    ``````\n    uint32_t seq = sock->window.wnd_send->nextseq;\n    uint32_t ack = sock->window.wnd_recv->expect_seq;\n    uint8_t flag = ACK_FLAG_MASK;\n    char *ACK = create_packet_buf(sock->established_local_addr.port, sock->established_remote_addr.port, seq, ack, DEFAULT_HEADER_LEN, DEFAULT_HEADER_LEN, flag, TCP_RECVWN_SIZE-(sock->unolen)*MAX_DLEN, 0, NULL, 0);\n    ``````\n}\n```\n### 发送方调整发送缓冲区大小\n**1. clientrdt( )**\n`clientrdt( )`函数确定window_size大小。\n```C\nvoid clientrdt(tju_tcp_t *sock, char *pkt){\n    ``````\n    ``````get_advertised_window(pkt)``````\n    ``````\n}\n```\n**2. get_advertised_window( )**\n```C\nuint16_t get_advertised_window(char* msg){\n    int offset = 17;\n    uint16_t var;\n    memcpy(&var, msg+offset, SIZE16);\n    return ntohs(var);\n}\n```\n### 0窗口探测\n**1. send_pkt( )**\n`send_pkt( )`发送数据的线程中加入一个判断条件。\n0窗口探测用于在ADVERTISED WINDOW为0的情况下，发送大小为1的数据报文以获得实时的窗口返回值。  \n```C\nvoid *send_pkt(tju_tcp_t* sock){\n    ``````\n    if((sock->window.wnd_send->nextseq > sock->window.wnd_send->base)&&sock->window.wnd_send->rwnd == 0){\n        len = 1;\n    }\n    if (len > 0){\n        ``````\n        ``````\n        ``````        \n    }\n    ``````\n}\n```\n## 拥塞控制\n### 慢启动\n**1. 套接字的初始化使得发送方从其他状态进入慢启动状态。**\n```C\ntju_tcp_t* tju_socket(){\n    sock->window.wnd_send->congestion_status = SLOW_START;\n}\n```\n**2. `resend_pkt( )`函数超时事件使得发送方从其他状态进入慢启动状态。**\n```C\nif (nowtimeval > timeoutval){\n    sock->window.wnd_send->congestion_status = SLOW_START;\n}\n```\n在慢启动状态下，发送方每当接收到正确的 ACK 报文，就会将其拥塞窗口增大 1 个 MSS（MAX_DLEN）。虽然是不断的自增 MSS，但是由于拥塞窗口的增大（进而导致发送窗口的增大），每次自增的次数为 1->2->4->8 直至达到ssthresh，所以拥塞窗口整体上呈现指数增长的趋势。\n**3. clientrdt( )**\n`clientrdt( )` 函数中发送方每当接收到正确的 ACK 报文，就会将其拥塞窗口增大 1 个 MSS。\n```C\nvoid clientrdt(tju_tcp_t *sock, char *pkt){   \n    ``````\n    if(sock->window.wnd_send->congestion_status == SLOW_START){ //慢启动\n        ``````    \n        else if(get_ack(pkt) > sock->window.wnd_send->base){ // new ack\n            sock->window.wnd_send->cwnd += MSS;\n            \n            while(pthread_mutex_lock(&(sock->window.wnd_send->ack_cnt_lock)) != 0);\n            sock->window.wnd_send->ack_cnt = 0;\n            pthread_mutex_unlock(&(sock->window.wnd_send->ack_cnt_lock));\n            ``````\n        }\n        ``````\n    }\n    ``````\n}\n```\n**4. resend_pkt( )**\n`resend_pkt( )` 函数中处理超时重传导致慢启动参数变化。\n```C\nvoid *resend_pkt(tju_tcp_t* sock){\n    ``````\n    if (nowtimeval > timeoutval){\n        sock->window.wnd_send->ssthresh = sock->window.wnd_send->cwnd / 2; //拥塞阈值变成拥塞窗口大小的一半\n        if(sock->window.wnd_send->ssthresh < MAX_DLEN) sock->window.wnd_send->ssthresh = MSS; //调整\n        sock->window.wnd_send->cwnd = MSS; //拥塞窗口变成1MSS\n        sock->window.wnd_send->congestion_status = SLOW_START; //拥塞状态不变\n    }\n    ``````\n}\n```\n### 拥塞避免\n**1. 拥塞窗口超过 ssthresh 进入拥塞避免状态。**\n```C\nvoid clientrdt(tju_tcp_t *sock, char *pkt){ \n    ``````\n    if(sock->window.wnd_send->congestion_status == SLOW_START){ //慢启动\n        ``````\n        if(sock->window.wnd_send->cwnd >= sock->window.wnd_send->ssthresh){ //cwnd达到ssthresh，转为拥塞避免状态\n            sock->window.wnd_send->congestion_status = CONGESTION_AVOIDANCE;\n        }\n        ``````\n    }\n    ``````\n}\n```\n**2. 快速恢复阶段收到正确的 ACK 使得发送方从其他状态进入拥塞避免状态。**\n```C\nvoid clientrdt(tju_tcp_t *sock, char *pkt){ \n    ``````\n    else if (sock->window.wnd_send->congestion_status == FAST_RECOVERY){ //快速恢复\n        ``````\n        else if(get_ack(pkt) > sock->window.wnd_send->base){ //new ack\n            sock->window.wnd_send->cwnd = sock->window.wnd_send->ssthresh;\n\n            while(pthread_mutex_lock(&(sock->window.wnd_send->ack_cnt_lock)) != 0);\n            sock->window.wnd_send->ack_cnt = 0;\n            pthread_mutex_unlock(&(sock->window.wnd_send->ack_cnt_lock));\n          \n            sock->window.wnd_send->window_size = min(get_advertised_window(pkt), sock->window.wnd_send->cwnd);\n\n            sock->window.wnd_send->congestion_status = CONGESTION_AVOIDANCE;\n        }\n    }\n    ``````\n}\n```\n**3. 在拥塞避免状态下，发送方每当收到一个正确的 ACK 报文，拥塞窗口就会增大（1/cwnd）个 MSS。拥塞窗口整体上呈现线性增长的趋势。**\n```C\nvoid clientrdt(tju_tcp_t *sock, char *pkt){   \n    ``````\n    else if (sock->window.wnd_send->congestion_status == CONGESTION_AVOIDANCE) { //拥塞避免\n        ``````\n        else if(get_ack(pkt) > sock->window.wnd_send->base){ //new ack\n            sock->window.wnd_send->cwnd += MSS * ((double)MSS / (double)sock->window.wnd_send->cwnd);\n\n            while(pthread_mutex_lock(&(sock->window.wnd_send->ack_cnt_lock)) != 0);\n            sock->window.wnd_send->ack_cnt = 0;\n            pthread_mutex_unlock(&(sock->window.wnd_send->ack_cnt_lock));\n            \n            sock->window.wnd_send->window_size = min(get_advertised_window(pkt), sock->window.wnd_send->cwnd);\n        }\n    }\n    ``````\n}\n```\n### 快速恢复\n**1. `clientrdt( )` 发送方收到 3 个冗余 ACK 时，进入快速恢复状态。**\n```C\nif(sock->window.wnd_send->ack_cnt == 3){  //快速重传\n    sock->window.wnd_send->ssthresh = sock->window.wnd_send->cwnd / 2;\n    sock->window.wnd_send->cwnd = sock->window.wnd_send->ssthresh + 3 * MSS;\n    sock->window.wnd_send->congestion_status = FAST_RECOVERY; //快速恢复\n    ``````\n}\n```\n**2. 在快速恢复状态下，如果还是收到冗余 ACK，那么依然在此状态，cwnd+=MSS；当收到正确 ACK 时，则进入拥塞避免状态 ，cwnd=ssthresh；当超时时，回到慢启动，cwnd=1MSS。**\n```C\nvoid clientrdt(tju_tcp_t *sock, char *pkt){ \n    ``````\n    ``````\n    ``````    \n    else if (sock->window.wnd_send->congestion_status == FAST_RECOVERY){ //快速恢复\n        if(get_ack(pkt) == sock->window.wnd_send->base){//dup ack\n            while(pthread_mutex_lock(&(sock->window.wnd_send->ack_cnt_lock)) != 0);\n            sock->window.wnd_send->ack_cnt++;\n            pthread_mutex_unlock(&(sock->window.wnd_send->ack_cnt_lock));\n\n            sock->window.wnd_send->cwnd += MSS;\n                        \n            sock->window.wnd_send->window_size = min(get_advertised_window(pkt), sock->window.wnd_send->cwnd);\n\n            sock->window.wnd_send->congestion_status = FAST_RECOVERY;\n            return;\n        }\n        else if(get_ack(pkt) > sock->window.wnd_send->base){ //new ack\n            sock->window.wnd_send->cwnd = sock->window.wnd_send->ssthresh;\n\n            while(pthread_mutex_lock(&(sock->window.wnd_send->ack_cnt_lock)) != 0);\n            sock->window.wnd_send->ack_cnt = 0;\n            pthread_mutex_unlock(&(sock->window.wnd_send->ack_cnt_lock));  \n         \n            sock->window.wnd_send->window_size = min(get_advertised_window(pkt), sock->window.wnd_send->cwnd);\n\n            sock->window.wnd_send->congestion_status = CONGESTION_AVOIDANCE;\n        }\n    }\n    ``````\n    ``````\n    ``````\n}\n```","tags":["计算机网络"]},{"title":"C语言手写Httpd网站服务器","url":"/2024/09/26/C语言手写Httpd网站服务器/","content":"\n---\n## 执行WEB服务前的准备工作\n### 创建项目\n```C\n#include <stdio.h>\n\n// 初始化网络并创建服务端的套接字\nint startup(unsigned short* port){\n    return 0;\n}\n\nint main(void){\n    //httpd默认的端口是80，这里指定了8000端口，也可以使用其它端口\n    unsigned short port = 8000;\n\n    // 初始化网络，并使用指定端口来创建服务端的套接字\n    int server_sock = startup(&port);\n    printf(\"httpd running on port %d\\n\", port);\n\n    return(0);\n}\n```\n### 网络通信初始化\n```C\n//网络通信需要包含的头文件、需要加载的库文件\n#include <winsock2.h>\n#pragma comment (lib, \"WS2_32.lib\")\n\n// 初始化网络并创建服务端的套接字\nint startup(unsigned short* port) {\n    WSADATA wsaData; // 网络通信相关的版本等信息\n    int ret = WSAStartup( // WSAStartup 网络通信初始化，\n        MAKEWORD(1, 1),   // 指定使用Windows Sockets规范的1.1版本\n        &wsaData);        // 存储初始化后的版本等信息结果\n    if (ret) {\n        return -1;\n    }\n\n    return 0;\n}\n```\n### 创建套接字\n```C\nvoid error_die(const char* sc) {\n    perror(sc); //打印错误原因\n    exit(1);\n}\n\n// 初始化网络并创建服务端的套接字\nint startup(unsigned short* port) {\n    int server_socket = socket(PF_INET, //套接字的类型（网络套接字、文件套接字，此处是前者）\n        SOCK_STREAM,  //数据包的类型（数据流、数据报，此处是前者）               \n        IPPROTO_TCP); //具体协议\n    if (server_socket == -1) { //打印错误提示，并结束程序\n        error_die(\"socket\");\n    }\n}\n```\n### 设置套接字属性--端口可复用\n```C\n// 初始化网络并创建服务端的套接字\nint startup(unsigned short* port) {\n    //设置端口可复用（端口复用）\n    int opt = 1;\n    ret = setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, (const char*)&opt, sizeof(opt));\n    if (ret == -1) {\n        error_die(\"setsockopt\");\n    }\n}\n```\n### 绑定套接字和网络地址\n```C\nint startup(unsigned short* port) {\n    //配置服务器的网络地址\n    struct sockaddr_in server_addr;\n    memset(&server_addr, 0, sizeof(server_addr));\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(*port);\n    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);\n    \n    //绑定套接字\n    if (bind(server_socket, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {\n        error_die(\"[bind]\");\n    }\n}\n```\n### 获取动态端口\n```C\nint startup(unsigned short* port) {\n    // 动态分配端口\n    if (*port == 0) {\n        int namelen = sizeof(server_addr);\n        if (getsockname(server_socket, (struct sockaddr*)&server_addr, &namelen) <0) {\n            error_die(\"getsockname\");\n        }\n        *port = ntohs(server_addr.sin_port);\n    }\n    return server_socket;\n}\n```\n### 创建监听队列\n```C\nint startup(unsigned short* port) {\n    //创建监听队列\n    if (listen(server_socket, 5) < 0) {\n        error_die(\"listen\");\n    }\n    return server_socket;\n}\n```","tags":["c","服务器"]},{"title":"C语言手写植物大战僵尸","url":"/2024/09/26/C语言手写植物大战僵尸/","content":"\n---\n## C语言手写植物大战僵尸\n### 创建主场景\n```C\n#include<stdio.h>\n#include<graphics.h>\n\n#define WIN_WIDTH 900\n#define WIN_HEIGHT 600\n\nIMAGE imgBg;\n\n//游戏初始化\nvoid gameInit() {\n\tloadimage(&imgBg, \"res/bg.jpg\");\n\n\tinitgraph(WIN_WIDTH, WIN_HEIGHT);\n}\n\n//更新窗口\nvoid updateWindow() {\n\tputimage(0, 0, &imgBg);\n}\n\nint main(void) {\n\t//游戏初始化\n\tgameInit();\n\n\t//更新窗口\n\tupdateWindow();\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n### 实现植物卡牌\n```C\n#include \"tools.h\"\n\n//#define ZHI_WU_CUNT 3\n\nenum { WAN_DOU, XIANG_RI_KUI, ZHI_WU_COUNT };\n\nIMAGE imgBar;\nIMAGE imgCards[ZHI_WU_COUNT];\n\nvoid gameInit() {\n\tloadimage(&imgBar, \"res/bar.png\");\n\n\t//初始化植物卡牌\n\tchar name[64];\n\tfor (int i = 0; i < ZHI_WU_COUNT; i++) {\n\t\t//生成植物卡牌的文件名\n\t\tsprintf_s(name, sizeof(name), \"res/Cards/card_%d.png\", i + 1);\n\t\tloadimage(&imgCards[i], name);\n\t}\n}\n\nvoid updateWindow() {\n\t//putimage(250, 0, &imgBar); //有黑边\n\tputimagePNG(250, 0, &imgBar);\n\n\tfor (int i = 0; i < ZHI_WU_COUNT; i++) {\n\t\tint x = 338 + i * 65;\n\t\tint y = 6;\n\t\tputimage(x, y, &imgCards[i]);\n\t}\n}\n```\n### 实现植物的选择和拖动\n```C\nIMAGE* imgZhiWu[ZHI_WU_COUNT][20];\n\nint curX, curY; //当前选中的植物，在移动过程中的位置\nint curZhiWu; //0:没有选中，1:选择了第一种植物 etc.\n\nbool fileExist(const char* name) {\n\tFILE* fp = fopen(name, \"r\");\n\tif (fp == NULL) {\n\t\treturn false;\n\t}\n\telse {\n\t\tfclose(fp);\n\t\treturn true;\n\t}\n}\n\nvoid gameInit() {\n\tmemset(imgZhiWu, 0, sizeof(imgZhiWu));\n\n\t//初始化植物卡牌\n\tchar name[64];\n\tfor (int i = 0; i < ZHI_WU_COUNT; i++) {\n\t\tfor (int j = 0; j < 20; j++) {\n\t\t\tsprintf_s(name, sizeof(name), \"res/zhiwu/%d/%d.png\", i, j + 1);\n\t\t\t//先判断这个文件是否存在\n\t\t\tif (fileExist(name)) {\n\t\t\t\timgZhiWu[i][j] = new IMAGE;\n\t\t\t\tloadimage(imgZhiWu[i][j], name);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tcurZhiWu = 0;\n\t//创建游戏的图形窗口\n\tinitgraph(WIN_WIDTH, WIN_HEIGHT, 1); //加一个参数1，保留后台界面，方便调试\n}\n\nvoid updateWindow() {\n\tBeginBatchDraw(); //开始缓冲（先打印到内存中）\n\n\t//渲染 拖动过程中的植物\n\tif (curZhiWu > 0) {\n\t\tIMAGE* img = imgZhiWu[curZhiWu - 1][0];\n\t\tputimagePNG(curX - img->getwidth() / 2, curY - img->getheight() / 2, img);\n\t}\n\n\tEndBatchDraw(); //结束双缓冲（再一次性打印到窗口）\n}\nvoid userClick() {\n\tExMessage msg;\n\tstatic int status = 0;//状态变量（先点击再拖动）\n\tif (peekmessage(&msg)) {\n\t\tif (msg.message == WM_LBUTTONDOWN) { //左击按下\n\t\t\tif (msg.x > 338 && msg.x < 338 + 65 * ZHI_WU_COUNT && msg.y < 96) {\n\t\t\t\tint index = (msg.x - 338) / 65; //选择卡牌序号\n\t\t\t\tprintf(\"%d\\n\", index);\n\t\t\t\tstatus = 1; //可以拖动\n\t\t\t\tcurZhiWu = index + 1;\n\t\t\t}\n\t\t}\n\t\telse if (msg.message == WM_MOUSEMOVE && status == 1) { //鼠标移动\n\t\t\tcurX = msg.x;\n\t\t\tcurY = msg.y;\n\n\t\t}\n\t\telse if (msg.message == WM_LBUTTONUP) { //左键抬起\n\n\t\t}\n\t}\n\n}\nint main(void) {\n\tgameInit();\n\n\twhile (1) {\n\t\tuserClick();\n\n\t\tupdateWindow();\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n### 实现植物的种植\n```C\nstruct zhiwu {\n\tint type;\t\t//0:没有选中，1:第一种植物\tetc.\t\t\t\t\n\tint frameIndex; //序列帧的序号\n};\n\nstruct zhiwu map[3][9];\n\nvoid gameInit() {\n\tmemset(map, 0, sizeof(map));\n}\n\nvoid updateWindow() {\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 9; j++) {\n\t\t\tif (map[i][j].type > 0) {\n\t\t\t\tint x = 256 + j * 81;\n\t\t\t\tint y = 179 + i * 102 + 14;\n\t\t\t\tint zhiWuType = map[i][j].type - 1;\n\t\t\t\tint index = map[i][j].frameIndex;\n\t\t\t\tputimagePNG(x, y, imgZhiWu[zhiWuType][index]);\n\t\t\t}\n\t\t}\n\t}\n}\nvoid userClick() {\n\tif (peekmessage(&msg)) {\n\t\telse if (msg.message == WM_LBUTTONUP) { //左键抬起\n\t\t\tif (msg.x > 256 && msg.y > 179 && msg.y < 489) {\n\t\t\t\tint row = (msg.y - 179) / 102;\n\t\t\t\tint col = (msg.x - 256) / 81;\n\t\t\t\t//printf(\"%d, %d\\n\", row, col);\n\t\t\t\tif (map[row][col].type == 0) {\n\t\t\t\t\tmap[row][col].type = curZhiWu;\n\t\t\t\t\tmap[row][col].frameIndex = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurZhiWu = 0;\n\t\t\tstatus = 0;\n\t\t}\n\t}\n}\n```\n### 实现植物的摇摆\n```C\n//更新游戏相关数据\nvoid updateGame() {\n\tfor (int i = 0; i < 3; i++) {\n\t\tfor (int j = 0; j < 9; j++) {\n\t\t\tif (map[i][j].type > 0) {\n\t\t\t\tmap[i][j].frameIndex++;\n\t\t\t\tint zhiWuType = map[i][j].type - 1;\n\t\t\t\tint index = map[i][j].frameIndex;\n\t\t\t\tif (imgZhiWu[zhiWuType][index] == NULL) {\n\t\t\t\t\tmap[i][j].frameIndex = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void) {\n\tgameInit();\n\twhile (1) {\n\t\tuserClick();\n\n\t\tupdateWindow();\n\t\tupdateGame(); //更新游戏相关数据\n\n\t\tSleep(10);//帧等待\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n### 优化游戏循环和游戏渲染循序\n```C\nvoid updateWindow() {\n\tBeginBatchDraw(); //开始缓冲\n\n\t//渲染 拖动过程中的植物（放到了最后）\n\tif (curZhiWu > 0) {\n\t\tIMAGE* img = imgZhiWu[curZhiWu - 1][0];\n\t\tputimagePNG(curX - img->getwidth() / 2, curY - img->getheight() / 2, img);\n\t}\n\n\tEndBatchDraw(); //结束双缓冲\n}\n\nint main(void) {\n\tgameInit();\n\tint timer = 0;\n\tbool flag = true;\n\twhile (1) {\n\t\tuserClick();\n\t\ttimer += getDelay();\n\t\tif (timer > 20) {\n\t\t\tflag = true;\n\t\t\ttimer = 0;\n\t\t}\n\n\t\tif (flag) {\n\t\t\tflag = false;\n\t\t\tupdateWindow();\n\t\t\tupdateGame();\n\t\t}\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n### 制作启动菜单\n```C\nvoid startUI() { //启动菜单\n\tIMAGE imgBg,imgMenu1,imgMenu2;\n\tloadimage(&imgBg, \"res/menu.png\");\n\tloadimage(&imgMenu1, \"res/menu1.png\");\n\tloadimage(&imgMenu2, \"res/menu2.png\");\n\n\tint flag = 0;\n\twhile (1) {\n\t\tBeginBatchDraw();\n\t\tputimage(0, 0, &imgBg);\n\t\tputimagePNG(474, 75, flag ? &imgMenu2: &imgMenu1);\n\n\t\tExMessage msg;\n\t\tif (peekmessage(&msg)) {\n\t\t\tif (msg.message == WM_LBUTTONDOWN&&\n\t\t\t\t\tmsg.x>474&&msg.x<474+300&&\n\t\t\t\t\tmsg.y>75&&msg.y<75+140){\n\t\t\t\tflag = 1;\n\t\t\t\t//EndBatchDraw();\n\t\t\t}\n\t\t\telse if (msg.message == WM_LBUTTONUP&&flag) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tEndBatchDraw();\n\t}\n}\n\nint main(void) {\n\tgameInit();\n\n\tstartUI();\n\n\tint timer = 0;\n\tbool flag = true;\n\twhile (1) {\n\t\tuserClick();\n\t\ttimer += getDelay();\n\t\tif (timer > 20) {\n\t\t\tflag = true;\n\t\t\ttimer = 0;\n\t\t}\n\n\t\tif (flag) {\n\t\t\tflag = false;\n\t\t\tupdateWindow();\n\t\t\tupdateGame();\n\t\t}\n\n\t\tSleep(10);\n\t}\n\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n### 创建随机阳光\n```C\n#include<time.h>\n\nstruct sunshineBall {\n\tint x, y; //阳光球在飘落过程中的坐标位置（x不变）\n\tint frameIndex; //当前显示的图片帧的序号\n\tint destY; //飘落的目标位置的y坐标\n\tbool used; //是否在使用\n};\n\n//阳光池\nstruct sunshineBall balls[10];\nIMAGE imgSunshineBall[29];\n\n\nvoid gameInit() {\n\tmemset(balls, 0, sizeof(balls));\n\tfor (int i = 0; i < 29; i++) {\n\t\tsprintf_s(name, sizeof(name), \"res/sunshine/%d.png\", i + 1);\n\t\tloadimage(&imgSunshineBall[i], name);\n\t}\n\n\t//配置随机种子\n\tsrand(time(NULL));\n}\n\nvoid creatSunshine() {\n\tstatic int count = 0;\n\tstatic int fre = 400;\n\tcount++;\n\tif (count >= fre) { //每fre帧创建一个阳光，fre随机改变\n\t\tfre = 200 + rand() % 200;\n\t\tcount = 0;\n\n\t\t//从阳光池中取一个可以使用的\n\t\tint ballMax = sizeof(balls) / sizeof(balls[0]);\n\n\t\tint i;\n\t\tfor (i = 0; i < ballMax && balls[i].used; i++);\n\t\tif (i >= ballMax) return;\n\n\t\tballs[i].used = true;\n\t\tballs[i].frameIndex = 0;\n\t\tballs[i].x = 260 + rand() % (900 - 260);\n\t\tballs[i].y = 60;\n\t\tballs[i].destY = 200 + (rand() % 4) * 90;\n\t}\n}\n\nvoid updateGame() {\n\tcreatSunshine();\n}\n```\n### 显示随机阳光\n```C\nstruct sunshineBall {\n\tint x, y; //阳光球在飘落过程中的坐标位置（x不变）\n\tint frameIndex; //当前显示的图片帧的序号\n\tint destY; //飘落的目标位置的y坐标\n\tbool used; //是否在使用\n\tint timer; //计时器\n};\n\nvoid updateWindow() {\n\tint ballMax = sizeof(balls) / sizeof(balls[0]);\n\tfor (int i = 0; i < ballMax; i++) {\n\t\tif (balls[i].used) {\n\t\t\tIMAGE* img = &imgSunshineBall[balls[i].frameIndex];\n\t\t\tputimagePNG(balls[i].x, balls[i].y, img);\n\t\t}\n\t}\n}\n\t\nvoid creatSunshine() {\n\tif (count >= fre) {\n\t\tballs[i].timer = 0;\n\t}\n}\n\nvoid updateSunshine() {\n\tint ballMax = sizeof(balls) / sizeof(balls[0]);\n\tfor (int i = 0; i < ballMax; i++) {\n\t\tif (balls[i].used) {\n\t\t\tballs[i].frameIndex = (balls[i].frameIndex + 1) % 29;\n\t\t\tif (balls[i].timer == 0) { //未到达地面\n\t\t\t\tballs[i].y += 2;\n\t\t\t}\n\t\t\tif (balls[i].y >= balls[i].destY) {\n\t\t\t\t//balls[i].used = false;\n\t\t\t\tballs[i].timer++;\n\t\t\t\tif (balls[i].timer > 100) { //掉到地面100帧之后\n\t\t\t\t\tballs[i].used = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid updateGame() {\n\tcreatSunshine(); //创建阳光\n\tupdateSunshine(); //更新阳光的状态\n}\n```\n### 收集阳光、显示阳光值\n```C\n#include<mmsystem.h>\n#pragma comment(lib,\"winmm.lib\")\n\nint sunshine; //总阳光值\n\nvoid gameInit() {\n\tsunshine = 150;\n\n\t//设置字体\n\tLOGFONT f;\n\tgettextstyle(&f);                     // 获取当前字体设置\n\tf.lfHeight = 30;                      // 设置字体高度为 48\n\tf.lfWidth = 15;\n\tstrcpy(f.lfFaceName, \"Segoe UI Black\"); \n\tf.lfQuality = ANTIALIASED_QUALITY;    // 设置输出效果为抗锯齿  \n\tsettextstyle(&f);                     // 设置字体样式\n\tsetbkmode(TRANSPARENT);\t\t\t\t  //背景模式透明\n\tsetcolor(BLACK);\t\t\t\t\t  //字体颜色\n}\n\nvoid updateWindow() {\n\tchar scoreText[8];\n\tsprintf_s(scoreText, sizeof(scoreText), \"%d\", sunshine);\n\touttextxy(276, 67, scoreText); //在指定位置输出文本--分数\n}\n\nvoid collectSunshine(ExMessage* msg) {\n\tint count = sizeof(balls) / sizeof(balls[0]);\n\tint w = imgSunshineBall[0].getwidth(); //阳光球宽度\n\tint h = imgSunshineBall[0].getheight();//阳光球高度\n\tfor (int i = 0; i < count; i++) {\n\t\tif (balls[i].used) {\n\t\t\tint x = balls[i].x;\n\t\t\tint y = balls[i].y;\n\t\t\tif (msg->x > x && msg->x < x + w && msg->y > y && msg->y < y + h) {\n\t\t\t\tballs[i].used = false;\n\t\t\t\tsunshine += 25;\n\t\t\t\tmciSendString(\"play res/sunshine.mp3\", 0, 0, 0); //添加音效\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid userClick() {\n\tExMessage msg;\n\tstatic int status = 0;\n\tif (peekmessage(&msg)) {\n\t\tif (msg.message == WM_LBUTTONDOWN) { //左击按下\n\t\t\tif (msg.x > 338 && msg.x < 338 + 65 * ZHI_WU_COUNT && msg.y < 96) {\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcollectSunshine(&msg);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}\n```","tags":["c","PvZ"]},{"title":"Java 综合实战（一）","url":"/2024/09/24/Java 综合实战/","content":"\n---\n## Java 综合实战（一）\n### 健康计算器\n**需求：开发一个简单的健康计算器应用程序，它可以接受用户的输入（如年龄、性别、体重、身高），并计算出用户的 BMI（身体质量指数）和 BMR（基础代谢率）。**\n```Java\npackage test;\n\nimport java.util.Scanner;\n\npublic class test {\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n\n        System.out.println(\"请您输入您的身高：\");\n        double height=sc.nextDouble();\n\n        System.out.println(\"请您输入您的体重：\");\n        double weight=sc.nextDouble();\n\n        System.out.println(\"请您输入您的性别（男/女）：\");\n        String sex=sc.next();\n\n        System.out.println(\"请您输入您的年龄：\");\n        int age=sc.nextInt();\n\n        double bmi=calcBMI(height,weight);\n        System.out.println(\"您的BMI值为：\"+bmi);\n\n        double bmr=calcBMR(height,weight,age,sex);\n        System.out.println(\"您的BMR值为：\"+bmr);\n    }\n\n    public static double calcBMI(double height,double weight){\n        return weight/(height*height);\n    }\n\n    public static double calcBMR(double height,double weight,int age,String sex){\n        double bmr=0;\n        if(sex.equals(\"男\")){\n            bmr=88.362+13.397*weight+4.799*height-5.677*age;\n        }\n        else{\n            bmr=447.593+9.247*weight+3.098*height-4.330*age;\n        }\n        return bmr;\n    }\n}\n```\n### 简单计算器\n**需求：设计一个可以执行基本数学运算（加、减、乘、除）的计算器程序。** \n**功能描述：用户输入两个数字、一个运算符（+、-、*、/）。根据所选运算符执行相应的数学运算，显示运算结果。**\n```Java\npackage test1;\n\nimport java.util.Scanner;\n\npublic class test1 {\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n\n        System.out.println(\"请输入第一个数字：\");\n        double num1=sc.nextDouble();\n\n        System.out.println(\"请输入第二个数字：\");\n        double num2=sc.nextDouble();\n\n        System.out.println(\"请输入运算符（+、-、*、/）：\");\n        String operator=sc.next();\n\n        double result=calculate(num1,num2,operator);\n        System.out.println(\"计算结果为：\"+result);\n    }\n\n    public static double calculate(double num1,double num2,String operator){\n        double result=0;\n        switch (operator){\n            case \"+\":\n                result=num1+num2;\n                break;\n            case \"-\":\n                result=num1-num2;\n                break;\n            case \"*\":\n                result=num1*num2;\n                break;\n            case \"/\":\n                result=num1/num2;\n                break;\n            default:\n                System.out.println(\"输入的运算符有误！\");\n        }\n        return result;\n    }\n}\n```\n### 猜数字小游戏\n**需求：随机生成一个1-100之间的数据，提示用户猜测，猜大提示过大，猜小提示过小，直到猜中结束游戏。**\n```Java\npackage test1;\n\nimport java.util.Random;\nimport java.util.Scanner;\n\npublic class test2 {\n    public static void main(String[] args) {\n        guessNumber();\n    }\n\n    public static void guessNumber(){\n        /*方法一*/\n        //Math.random()返回[0,1)之间的随机小数\n        //(int)(Math.random()*100)==>[0,100)的整数==>[0,99]+1==>[1,100]\n        //int number=(int)(Math.random()*100)+1;\n\n        /*方法二*/\n        Random r=new Random();\n        int number=r.nextInt(100)+1;\n\n        Scanner sc=new Scanner(System.in);\n\n        while(true){\n            System.out.println(\"请输入一个1~100之间的数字：\");\n            int guess=sc.nextInt();\n            if(guess<number){\n                System.out.println(\"猜小了，再试试吧！\");\n            }\n            else if(guess>number){\n                System.out.println(\"猜大了，再试试吧！\");\n            }\n            else{\n                System.out.println(\"恭喜你猜对了！\");\n                break;\n            }\n        }\n    }\n}\n```\n### 开发一个验证码\n**需求：开发一个程序，可以生成指定位数的验证码，每位可以是数字，大小写字母。**\n```Java\npackage test1;\n\npublic class test3 {\n    public static void main(String[] args) {\n        System.out.println(getCode(6));\n    }\n\n    public static String getCode(int n){\n        String code=\"\";\n\n        for(int i=0;i<n;i++){\n            int type=(int)(Math.random()*3); //数字0/大写1/小写2\n            \n            switch(type){\n                case 0:\n                    int num=(int)(Math.random()*10);\n                    code+=num;\n                    break;\n                case 1:\n                    int num1=(int)(Math.random()*26)+65;\n                    code+=(char)num1;\n                    break;\n                case 2:\n                    int num2=(int)(Math.random()*26)+97;\n                    code+=(char)num2;\n                    break;\n            }\n        }\n        return code;\n    }\n}\n```\n### 找素数\n**需求：输出101-200之间的所有素数以及总个数。**\n```Java\npackage test1;\n\npublic class test4 {\n    public static void main(String[] args) {\n        //目标：找出101-200之间的全部素数\n        int count=0;\n        for(int i=101;i<=200;i++){\n            if(isPrime(i)){\n                System.out.println(i);\n                count++;\n            }\n        }\n        System.out.println(\"素数的个数为：\"+count);\n    }\n\n    public static boolean isPrime(int num){\n        for(int i=2;i*i<=num;i++){\n            if(num%i==0){\n                return false;\n            }\n        }\n        return true;\n    }\n}\n```\n### 斗地主游戏\n**需求：开发一个简易版的斗地主游戏，要求只完成做牌（存储54张牌）、洗牌。**\n```Java\npackage test2;\n\npublic class test1 {\n    public static void main(String[] args) {\n       start();\n    }\n    public static void start(){\n        String[] poker=new String[54];\n        String[] colors={\"♠\",\"♥\",\"♣\",\"♦\"};\n        String[] nums={\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"J\",\"Q\",\"K\",\"A\"};\n\n        int index=0;\n        for(int i=0;i<colors.length;i++){\n            for(int j=0;j<nums.length;j++){\n                poker[index++]=colors[i]+nums[j];\n            }\n        }\n        poker[index++]=\"Big Joker\";\n        poker[index++]=\"Small Joker\";\n\n        //打印牌\n        for(int i=0;i<poker.length;i++){\n            System.out.print(poker[i]+\"\\t\");\n        }\n        System.out.println();\n\n        //洗牌\n        for(int i=0;i<poker.length;i++){\n            int j=(int)(Math.random()*poker.length);\n            String temp=poker[i];\n            poker[i]=poker[j];\n            poker[j]=temp;\n        }\n\n        System.out.println(\"洗牌后：\");\n        for(int i=0;i<poker.length;i++){\n            System.out.print(poker[i]+\"\\t\");\n        }\n        System.out.println();\n    }\n}\n```\n### 石头迷阵游戏\n**需求：只需完成数据初始化**\n```Java\npackage test2;\n\npublic class test2 {\n    public static void main(String[] args) {\n        start(5);\n    }\n    public static void start(int n) {\n       int[][] arr=new int[n][n];\n\n       int count=1;\n       for(int i=0;i<n;i++){\n           for(int j=0;j<n;j++){\n               arr[i][j]=count++;\n           }\n       }\n\n       print(arr);\n\n       //打乱二维数组中的元素顺序\n        for(int i=0;i<arr.length;i++){\n            for(int j=0;j<arr[i].length;j++){\n                int x=(int)(Math.random()*arr.length);\n                int y=(int)(Math.random()*arr[i].length);\n                int temp=arr[i][j];\n                arr[i][j]=arr[x][y];\n                arr[x][y]=temp;\n            }\n        }\n        System.out.println(\"------------------\");\n        System.out.println(\"打乱后：\");\n        print(arr);\n    }\n    public static void print(int[][] arr){\n        for(int i=0;i<arr.length;i++){\n            for(int j=0;j<arr[i].length;j++){\n                System.out.print(arr[i][j]+\"\\t\");\n            }\n            System.out.println();\n        }\n    }\n}\n```","tags":["Java"]},{"title":"Markdown 语法","url":"/2024/09/09/Markdown语法/","content":"\n## Markdown 标题\n``` markdown\n# 一级标题\n\n## 二级标题\n\n### 三级标题\n\n#### 四级标题\n\n##### 五级标题\n\n###### 六级标题\n```\n&nbsp;**或者在文本下方添加任意数量的 = 或 - 分别用于表示一级标题或二级标题**\n``` markdown\n一级标题\n=========\n\n二级标题\n---------\n```\n\n## Markdown 字体\n``` markdown\n*斜体文字*\n\n_斜体文字_\n\n**粗体文字**\n\n__粗体文字__\n\n***粗斜体文字***\n\n___粗斜体文字___\n```\n\n## Markdown 引用\n``` markdown\n>这是引用的内容\n\n>>这是引用的内容\n\n>>>>>>>>>>这是引用的内容\n```\n\n## Markdown 分割线\n&nbsp;**三个或者三个以上的 - 或者 * 或者 _ 都可以**\n``` markdown\n---\n\n****\n\n____\n```\n  \n## Markdown 下划线\n``` markdown\n<u>带下划线文本</u>   \n```\n\n## Markdown 删除线\n``` markdown \n~~tencent.com~~\n```\n\n## Markdown 图片\n### 插入互联网上图片\n``` markdown\n![图片描述](图片链接 ''图片title'')\n```\n>图片描述就是显示在图片下面的文字，相当于对图片内容的解释。\n图片title是图片的标题，当鼠标移到图片上时显示的内容。\n注意：title可加可不加，图片描述可写可不写。\n\n### 插入本地图片\n``` markdown\n![图片描述](图片本地路径 ''图片title'')\n```\n>图片描述就是显示在图片下面的文字，相当于对图片内容的解释。\n图片title是图片的标题，当鼠标移到图片上时显示的内容。\n注意：title可加可不加，图片描述可写可不写。\n\n## Markdown 超链接\n``` markdown\n[超链接名](超链接地址 \"超链接title\")\n```\n&nbsp;**注：title可加可不加**\n\n## Markdown 列表\n### 无序列表\n&nbsp;**无序列表用 - + * 任何一种都可以**\n``` markdown\n* 第一项\n* 第二项\n* 第三项\n\n+ 第一项\n+ 第二项\n+ 第三项\n\n- 第一项\n- 第二项\n- 第三项\n```\n### 有序列表\n``` markdown\n1. 第一项\n2. 第二项\n3. 第三项\n```\n### 嵌套列表\n&nbsp;**上一级和下一级之间敲一个Tab键即可**\n``` markdown\n1. 第一项：\n    - 第一项嵌套的第一个元素\n    - 第一项嵌套的第二个元素\n2. 第二项：\n    - 第二项嵌套的第一个元素\n    - 第二项嵌套的第二个元素\n```\n\n## Markdown 表格\n``` markdown\n|表头|表头|表头|\n|---|:--:|---:|\n|内容|内容|内容|\n|内容|内容|内容|\n```\n\n>第二行分割表头和内容\n>-有一个就行，为了对齐，多加了几个\n>文字默认居左\n>-两边加：表示文字居中\n>-右边加：表示文字居右\n\n## Markdown 代码\n### 单行代码\n``` markdown\n`hello world`\n```\n\n### 代码块\n``` markdown\n(```)语言\n  代码内容\n(```)\n```\n\n## Markdown 流程图\n``` markdown\n(```)flow\nst=>start: 开始\nop=>operation: My Operation\ncond=>condition: Yes or No?\ne=>end\nst->op->cond\ncond(yes)->e\ncond(no)->op\n(```)\n```\n## Markdown 换行\n``` markdown\n连续两个以上空格+回车\n```\n&nbsp;**或者**\n``` markdown\n使用html语言换行标签<br>\n```\n\n## Markdown 缩进字符\n``` markdown\n&nbsp;  缩进1/4中文\n&ensp;  缩进半个中文，一个字符\n&emsp;  缩进一个中文，2个字符\n```","tags":["Markdown"]},{"title":"Hello World","url":"/2024/09/05/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]